<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>mic架构 | code life</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vuepress/images/logo.PNG">
    <meta name="description" content="这是我的第一个 VuePress 站点">
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.9807f3ec.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.d9de98a9.js" as="script"><link rel="preload" href="/vuepress/assets/js/3.9604ce54.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.e97bb777.js" as="script"><link rel="preload" href="/vuepress/assets/js/50.4fa99a04.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/1.5877fb11.js"><link rel="prefetch" href="/vuepress/assets/js/10.357844e2.js"><link rel="prefetch" href="/vuepress/assets/js/11.a4fdc236.js"><link rel="prefetch" href="/vuepress/assets/js/12.ebf202fc.js"><link rel="prefetch" href="/vuepress/assets/js/13.f024cbe7.js"><link rel="prefetch" href="/vuepress/assets/js/14.359a5b26.js"><link rel="prefetch" href="/vuepress/assets/js/15.afe7d426.js"><link rel="prefetch" href="/vuepress/assets/js/16.adb91c84.js"><link rel="prefetch" href="/vuepress/assets/js/17.a8d2cafa.js"><link rel="prefetch" href="/vuepress/assets/js/18.5c9ddf09.js"><link rel="prefetch" href="/vuepress/assets/js/19.ae65a10a.js"><link rel="prefetch" href="/vuepress/assets/js/20.3e05ef72.js"><link rel="prefetch" href="/vuepress/assets/js/21.f12f07ab.js"><link rel="prefetch" href="/vuepress/assets/js/22.19ce3ea4.js"><link rel="prefetch" href="/vuepress/assets/js/23.af18aaef.js"><link rel="prefetch" href="/vuepress/assets/js/24.b0b0b081.js"><link rel="prefetch" href="/vuepress/assets/js/25.5a1a21ce.js"><link rel="prefetch" href="/vuepress/assets/js/26.ff3159e0.js"><link rel="prefetch" href="/vuepress/assets/js/27.1ff63bdd.js"><link rel="prefetch" href="/vuepress/assets/js/28.1040a5c9.js"><link rel="prefetch" href="/vuepress/assets/js/29.eee1b359.js"><link rel="prefetch" href="/vuepress/assets/js/30.d536fc47.js"><link rel="prefetch" href="/vuepress/assets/js/31.1ec6d48e.js"><link rel="prefetch" href="/vuepress/assets/js/32.354d85e8.js"><link rel="prefetch" href="/vuepress/assets/js/33.9c50ed1d.js"><link rel="prefetch" href="/vuepress/assets/js/34.b1e31076.js"><link rel="prefetch" href="/vuepress/assets/js/35.856ee425.js"><link rel="prefetch" href="/vuepress/assets/js/36.bea5e353.js"><link rel="prefetch" href="/vuepress/assets/js/37.d6b25ed4.js"><link rel="prefetch" href="/vuepress/assets/js/38.dd6ba06e.js"><link rel="prefetch" href="/vuepress/assets/js/39.dcbd3f01.js"><link rel="prefetch" href="/vuepress/assets/js/4.94cb85d2.js"><link rel="prefetch" href="/vuepress/assets/js/40.ae1a56da.js"><link rel="prefetch" href="/vuepress/assets/js/41.cfc03d2b.js"><link rel="prefetch" href="/vuepress/assets/js/42.47ea3ebc.js"><link rel="prefetch" href="/vuepress/assets/js/43.009d556b.js"><link rel="prefetch" href="/vuepress/assets/js/44.0d95445a.js"><link rel="prefetch" href="/vuepress/assets/js/45.3fb1937f.js"><link rel="prefetch" href="/vuepress/assets/js/46.28a63ea9.js"><link rel="prefetch" href="/vuepress/assets/js/47.06bf295d.js"><link rel="prefetch" href="/vuepress/assets/js/48.0d48e46c.js"><link rel="prefetch" href="/vuepress/assets/js/49.52502860.js"><link rel="prefetch" href="/vuepress/assets/js/5.88e9eb12.js"><link rel="prefetch" href="/vuepress/assets/js/51.0dd49b6f.js"><link rel="prefetch" href="/vuepress/assets/js/52.dc529728.js"><link rel="prefetch" href="/vuepress/assets/js/53.a6dec54d.js"><link rel="prefetch" href="/vuepress/assets/js/6.9ff5f155.js"><link rel="prefetch" href="/vuepress/assets/js/9.4bef6cbb.js"><link rel="prefetch" href="/vuepress/assets/js/vendors~docsearch.717a90f1.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.9807f3ec.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><img src="/vuepress/images/logo.PNG" alt="code life" class="logo"> <span class="site-name can-hide">code life</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/" class="nav-link">首页</a></div><div class="nav-item"><a href="/vuepress/pages/e93fa3/" class="nav-link">技术组件</a></div><div class="nav-item"><a href="/vuepress/pages/99b5b5/" class="nav-link">面试知识库</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="相关链接" class="dropdown-title"><!----> <span class="title" style="display:;">相关链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  测试百度的链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/vuepress/" class="nav-link">首页</a></div><div class="nav-item"><a href="/vuepress/pages/e93fa3/" class="nav-link">技术组件</a></div><div class="nav-item"><a href="/vuepress/pages/99b5b5/" class="nav-link">面试知识库</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="相关链接" class="dropdown-title"><!----> <span class="title" style="display:;">相关链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  测试百度的链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>第一个目录</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress/pages/99b5b5/" class="sidebar-link">first</a></li><li><a href="/vuepress/pages/8ca047/" class="sidebar-link">mic面试题目</a></li><li><a href="/vuepress/pages/4283bd/" aria-current="page" class="active sidebar-link">mic架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#zookeeper中的watch机制的原理" class="sidebar-link">Zookeeper中的Watch机制的原理？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#spring-中bean的作用域有哪些" class="sidebar-link">Spring 中Bean的作用域有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#spring-中bean的作用域有哪些-2" class="sidebar-link">Spring 中Bean的作用域有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#dubbo是如何动态感知服务下线的" class="sidebar-link">Dubbo是如何动态感知服务下线的？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#说一说mybatis里面的缓存机制" class="sidebar-link">说一说Mybatis里面的缓存机制</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#spring中事务的传播行为有哪些" class="sidebar-link">Spring中事务的传播行为有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#为什么要使用spring-框架" class="sidebar-link">为什么要使用Spring 框架？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#请简述一下伪共享的概念以及如何避免" class="sidebar-link">请简述一下伪共享的概念以及如何避免</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#怎么理解线程安全" class="sidebar-link">怎么理解线程安全？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#什么是双亲委派" class="sidebar-link">什么是双亲委派？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#什么是聚集索引和非聚集索引" class="sidebar-link">什么是聚集索引和非聚集索引</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#基于数组的阻塞队列arrayblockingqueue原理" class="sidebar-link">基于数组的阻塞队列ArrayBlockingQueue原理</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#threadlocal是什么-它的实现原理呢" class="sidebar-link">ThreadLocal是什么？它的实现原理呢？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#讲一下wait和notify这个为什么要在synchronized代码块中" class="sidebar-link">讲一下wait和notify这个为什么要在synchronized代码块中？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#说说缓存雪崩和缓存穿透的理解-以及如何避免" class="sidebar-link">说说缓存雪崩和缓存穿透的理解，以及如何避免？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#volatile关键字有什么用-它的实现原理是什么" class="sidebar-link">volatile关键字有什么用？它的实现原理是什么？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#请说一下你对分布式锁的理解-以及分布式锁的实现" class="sidebar-link">请说一下你对分布式锁的理解，以及分布式锁的实现</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#死锁的发生原因和怎么避免" class="sidebar-link">死锁的发生原因和怎么避免</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#spring-boot中自动装配机制的原理" class="sidebar-link">Spring Boot中自动装配机制的原理</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#redis和mysql如何保证数据一致性" class="sidebar-link">Redis和Mysql如何保证数据一致性</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#什么是服务网格" class="sidebar-link">什么是服务网格？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#请说一下网络四元组" class="sidebar-link">请说一下网络四元组</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#能谈一下cas机制吗" class="sidebar-link">能谈一下CAS机制吗？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#b树和b-树的理解" class="sidebar-link">b树和b+树的理解</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#concurrenthashmap-底层具体实现知道吗-实现原理是什么" class="sidebar-link">ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#dubbo的服务请求失败怎么处理" class="sidebar-link">Dubbo的服务请求失败怎么处理？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#什么叫做阻塞队列的有界和无界" class="sidebar-link">什么叫做阻塞队列的有界和无界</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#hashmap是怎么解决哈希冲突的" class="sidebar-link">HashMap是怎么解决哈希冲突的？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#线程池如何知道一个线程的任务已经执行完成" class="sidebar-link">线程池如何知道一个线程的任务已经执行完成</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#lock和synchronized区别" class="sidebar-link">lock和synchronized区别</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#cpu飙高系统反应慢怎么排查" class="sidebar-link">CPU飙高系统反应慢怎么排查？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#innodb如何解决幻读" class="sidebar-link">innoDB如何解决幻读</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#kafka的零拷贝原理" class="sidebar-link">Kafka的零拷贝原理?</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#spring-boot的约定优于配置-你的理解是什么" class="sidebar-link">Spring Boot的约定优于配置，你的理解是什么？</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#谈谈你对seata的理解" class="sidebar-link">谈谈你对Seata的理解</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#fail-safe机制与fail-fast机制分别有什么作用" class="sidebar-link">Fail-safe机制与Fail-fast机制分别有什么作用</a></li><li class="sidebar-sub-header level2"><a href="/vuepress/pages/4283bd/#谈谈你对aqs的理解" class="sidebar-link">谈谈你对AQS的理解</a></li></ul></li><li><a href="/vuepress/pages/f56c1b/" class="sidebar-link">mysql</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>第二个目录</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>第三个目录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/vuepress/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>面试知识库</span></li><li data-v-06225672><span data-v-06225672>第一个目录</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="javascript:;" data-v-06225672>蔡先生</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-06-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">mic架构<span class="title-tag">原创,优质</span></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="zookeeper中的watch机制的原理"><a href="#zookeeper中的watch机制的原理" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/516144563" target="_blank" rel="noopener noreferrer">Zookeeper中的Watch机制的原理？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，这个问题我打算从两个方面来回答。</p> <p>Zookeeper是一个分布式协调组件，为分布式架构下的多个应用组件提供了顺序访问控制能力。</p> <p>它的数据存储采用了类似于文件系统的树形结构，以节点的方式来管理存储在Zookeeper上的数据。</p> <p><img src="https://pic2.zhimg.com/v2-93fc86ca8978222a80cab14d91507d87_720w.jpg?source=d16d100b" alt="img"></p> <p>Zookeeper提供了一个Watch机制，可以让客户端感知到Zookeeper Server上存储的数据变化，这样一种机制可以让Zookeeper实现很多的场景，比如配置中心、注册中心等。</p> <p><img src="https://pic2.zhimg.com/v2-539c2c569727b7518d9a5322ddcb870d_720w.jpg?source=d16d100b" alt="img"></p> <p>Watch机制采用了Push的方式来实现，也就是说客户端和Zookeeper Server会建立一个长连接，一旦监听的指定节点发生了变化，就会通过这个长连接把变化的事件推送给客户端。</p> <p>Watch的具体流程分为几个部分：</p> <ul><li>首先，是客户端通过指定命令比如 <code>exists</code>、<code>get</code>，对特定路径增加watch</li> <li>然后服务端收到请求以后，用HashMap保存这个客户端会话以及对应关注的节点路径，同时客户端也会使用HashMap
存储指定节点和事件回调函数的对应关系。</li> <li>当服务端指定被watch的节点发生变化后，就会找到这个节点对应的会话，把变化的事件和节点信息发给这个客户端。</li> <li>客户端收到请求以后，从ZkWatcherManager里面对应的回调方法进行调用，完成事件变更的通知。</li></ul> <p><img src="https://pic2.zhimg.com/v2-7d71ca09baa71bf995db1a05c7982564_720w.jpg?source=d16d100b" alt="img"></p> <p>以上就是我对这个问题的理解！</p> <p>总结</p> <p>这个面试题呢，我认为考察的价值也很大，其实对于服务端的数据变更通知，</p> <p>无非就是pull和push两种方案，而这道题里面涉及到的技术点就是push的实现。</p> <p>在业务开发里面，也可能会涉及到类似的场景，比如消息通知，扫码登录等。</p> <p>如果你了解这些思想，那在解决这类问题的时候，会变得更加从容。</p> <h2 id="spring-中bean的作用域有哪些"><a href="#spring-中bean的作用域有哪些" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/515895236" target="_blank" rel="noopener noreferrer">Spring 中Bean的作用域有哪些？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，把Bean注入到IOC容器里面的方式有7种方式</p> <ol><li>使用xml的方式来声明Bean的定义，Spring容器在启动的时候会加载并解析这个xml，把bean装载到IOC容器中。</li> <li>使用@CompontScan注解来扫描声明了@Controller、@Service、@Repository、@Component注解的类。</li> <li>使用@Configuration注解声明配置类，并使用@Bean注解实现Bean的定义，这种方式其实是xml配置方式的一种演变，是Spring迈入到无配置化时代的里程碑。</li> <li>使用@Import注解，导入配置类或者普通的Bean</li> <li>使用FactoryBean工厂bean，动态构建一个Bean实例，Spring Cloud OpenFeign里面的动态代理实例就是使用FactoryBean来实现的。</li> <li>实现ImportBeanDefinitionRegistrar接口，可以动态注入Bean实例。这个在Spring Boot里面的启动注解有用到。</li> <li>实现ImportSelector接口，动态批量注入配置类或者Bean对象，这个在Spring Boot里面的自动装配机制里面有用到。</li></ol> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>工作了4年，IOC和DI都没有搞清楚，作为面试官， 想给你放水都放不了啊。</p> <p>这道题目也很有意义，要想更加优雅的去解决一些实际业务问题，首先得有足够多的工具积累。</p> <p>你可曾想过，Bean的注入竟然有这么多方式，而且还有些方式是没听过的呢？</p> <h2 id="spring-中bean的作用域有哪些-2"><a href="#spring-中bean的作用域有哪些-2" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/515895236" target="_blank" rel="noopener noreferrer">Spring 中Bean的作用域有哪些？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，这个问题可以从几个方面来回答。</p> <p>首先呢，Spring 框架里面的IOC容器，可以非常方便的去帮助我们管理应用里面的Bean对象实例。</p> <p>我们只需要按照Spring里面提供的xml或者注解等方式去告诉IOC容器，哪些Bean需要被IOC容器管理就行了。</p> <p>其次呢，既然是Bean对象实例的管理，那意味着这些实例，是存在生命周期，也就是所谓的作用域。</p> <p>理论上来说，常规的生命周期只有两种：</p> <ul><li>singleton， 也就是单例，意味着在整个Spring容器中只会存在一个Bean实例。</li> <li>prototype，翻译成原型，意味着每次从IOC容器去获取指定Bean的时候，都会返回一个新的实例对象。</li></ul> <p>但是在基于Spring框架下的Web应用里面，增加了一个会话纬度来控制Bean的生命周期，主要有三个选择</p> <ul><li>request， 针对每一次http请求，都会创建一个新的Bean</li> <li>session，以sesssion会话为纬度，同一个session共享同一个Bean实例，不同的session产生不同的Bean实例</li> <li>globalSession，针对全局session纬度，共享同一个Bean实例</li></ul> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>“技术框架的本质是去解决特定问题的，所以如果能够站在技术的角度去思考Spring”</p> <p>当遇到这种问题的时候，就可以像这个高手的回答一样，能够基于场景来推断出答案。</p> <p>就像我们现在写CRUD代码，它已经变成了一种基本能力去让我们完成复杂业务逻辑的开发。</p> <p>有任何不懂的技术面试题，欢迎随时私信我</p> <h2 id="dubbo是如何动态感知服务下线的"><a href="#dubbo是如何动态感知服务下线的" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/515191806" target="_blank" rel="noopener noreferrer">Dubbo是如何动态感知服务下线的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，面试官，关于这个问题，我从几个方面来回答。</p> <p>首先，Dubbo默认采用Zookeeper实现服务的注册与服务发现，简单来说啊，就是多个Dubbo服务之间的通信地址，是使用Zookeeper来维护的。</p> <p>在Zookeeper上，会采用树形结构的方式来维护Dubbo服务提供端的协议地址，</p> <p>Dubbo服务消费端会从Zookeeper Server上去查找目标服务的地址列表，从而完成服务的注册和消费的功能。</p> <p><img src="https://pic3.zhimg.com/v2-b2ce37b2093d377357151cf898c45db4_720w.jpg?source=d16d100b" alt="img"></p> <p>Zookeeper会通过心跳检测机制，来判断Dubbo服务提供端的运行状态，来决定是否应该把这个服务从地址列表剔除。</p> <p><img src="https://pic1.zhimg.com/v2-9a62ddd2571ab6d38b44fdc2d2545a65_720w.jpg?source=d16d100b" alt="img"></p> <p>当Dubbo服务提供方出现故障导致Zookeeper剔除了这个服务的地址，</p> <p>那么Dubbo服务消费端需要感知到地址的变化，从而避免后续的请求发送到故障节点，导致请求失败。</p> <p>也就是说Dubbo要提供服务下线的动态感知能力。</p> <p>这个能力是通过Zookeeper里面提供的Watch机制来实现的，</p> <p>简单来说呢，Dubbo服务消费端会使用Zookeeper里面的Watch来针对Zookeeper Server端的 <code>/providers</code>节点注册监听，</p> <p>一旦这个节点下的子节点发生变化，Zookeeper Server就会发送一个事件通知Dubbo Client端.</p> <p><img src="https://pic3.zhimg.com/v2-1a665fa387b191f01cde37ffd7538619_720w.jpg?source=d16d100b" alt="img"></p> <p>Dubbo Client端收到事件以后，就会把本地缓存的这个服务地址删除，这样后续就不会把请求发送到失败的节点上，完成服务下线感知。</p> <p>以上就是我对这个问题的理解！</p> <p><strong>总结</strong></p> <p>Dubbo是目前非常主流的开源RPC框架，在很多的企业都有使用。</p> <p>理解这个RPC底层的工作原理很有必要，它能帮助开发者提高开发问题的解决效率。</p> <p>还是想多说一句，在Java这个岗位上，如果想走得更远，一定要花苦功夫。</p> <p>本期的普通人VS高手面试系列就到这里结束了。</p> <p>有任何不懂的技术面试题，欢迎随时私信我</p> <h2 id="说一说mybatis里面的缓存机制"><a href="#说一说mybatis里面的缓存机制" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/514791896" target="_blank" rel="noopener noreferrer">说一说Mybatis里面的缓存机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>这个问题，有点复杂，我打算从几个方面来说明。</p> <p>首先，Mybatis里面设计了二级缓存来提升数据的检索效率，避免每次数据的访问都需要去查询数据库。</p> <p><img src="https://pic1.zhimg.com/v2-0654c5987ed463bf302c315d6077ae3e_720w.jpg?source=d16d100b" alt="img"></p> <p>一级缓存，是SqlSession级别的缓存，也叫本地缓存，因为每个用户在执行查询的时候都需要使用SqlSession来执行，</p> <p>为了避免每次都去查数据库，Mybatis把查询出来的数据保存到SqlSession的本地缓存中，后续的SQL如果命中缓存，就可以直接从本地缓存读取了。</p> <p>如果想要实现跨SqlSession级别的缓存？那么一级缓存就无法实现了，因此在Mybatis里面引入了二级缓存，就是当多个用户</p> <p>在查询数据的时候，只有有任何一个SqlSession拿到了数据就会放入到二级缓存里面，其他的SqlSession就可以从二级缓存加载数据。</p> <p>每个 一级缓存的具体实现原理是：</p> <p>在SqlSession 里面持有一个Executor，每个Executor中有一个LocalCache对象。</p> <p>当用户发起查询的时候，Mybatis会根据执行语句在Local Cache里面查询，如果没命中，再去查询数据库并写入到LocalCache，否则直接返回。</p> <p>所以，以及缓存的生命周期是SqlSessiion，而且在多个Sqlsession或者分布式环境下，可能会导致数据库写操作出现脏数据。</p> <p><img src="https://pic2.zhimg.com/v2-f5bad29d6ab127cf0f46e66b1c48c9fb_720w.jpg?source=d16d100b" alt="img"></p> <p>二级缓存的具体实现原理是：</p> <p>使用CachingExecutor装饰了Executor，所以在进入一级缓存的查询流程之前，会先通过CachingExecutor进行二级缓存的查询。</p> <p>开启二级缓存以后，会被多个SqlSession共享，所以它是一个全局缓存。因此它的查询流程是先查二级缓存，再查一级缓存，最后再查数据库。</p> <p>另外，MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时缓存粒度也能够到 namespace 级别，并且还可以通过 Cache 接口实现类不同的组合，对 Cache 的可控性也更强。</p> <p><img src="https://pic1.zhimg.com/v2-add6c2ea7aa586cfdea10b9b470d3f1f_720w.jpg?source=d16d100b" alt="img"></p> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>在实际业务场景中，多级缓存的设计思想，非常值得我们学习和借鉴。</p> <p>所以我认为这个面试题很不错。</p> <p>大家要牢记，学习底层技术的目的是为了提高技术思维能力和积累解决方案，为以后更高的职位做好铺垫。</p> <p>本期的普通人VS高手面试系列就到这里结束了。</p> <p>有任何不懂的技术面试题，欢迎随时私信我</p> <h2 id="spring中事务的传播行为有哪些"><a href="#spring中事务的传播行为有哪些" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/513700485" target="_blank" rel="noopener noreferrer">Spring中事务的传播行为有哪些？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>对于这个问题，需要从几个方面去回答。</p> <p>首选， 所谓的事务传播行为，就是多个声明了事务的方法相互调用的时候，这个事务应该如何传播。</p> <p>（如图）比如说，methodA()调用methodB()，两个方法都显示的开启了事务。</p> <p>那么methodB()是开启一个新事务，还是继续在methodA()这个事务中执行？就取决于事务的传播行为。</p> <p><img src="https://pic2.zhimg.com/v2-da7e90e0c9de492d5954c3b4c7c26307_720w.jpg?source=d16d100b" alt="img"><img src="https://pic2.zhimg.com/80/v2-da7e90e0c9de492d5954c3b4c7c26307_720w.jpg?source=d16d100b" alt="img"></p> <p>在Spring中，定义了7种事务传播行为。</p> <ol><li>REQUIRED：默认的Spring事物传播级别，如果当前存在事务，则加入这个事务，如果不存在事务，就新建一个事务。</li> <li>REQUIRE_NEW：不管是否存在事务，都会新开一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。</li> <li>NESTED：如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务， 则新建一个事务，类似于REQUIRE_NEW。</li> <li>SUPPORTS：表示支持当前事务，如果当前不存在事务，以非事务的方式执行。</li> <li>NOT_SUPPORTED：表示以非事务的方式来运行，如果当前存在事务，则把当前事务挂起。</li> <li>MANDATORY：强制事务执行，若当前不存在事务，则抛出异常.</li> <li>NEVER：以非事务的方式执行，如果当前存在事务，则抛出异常。</li></ol> <p>Spring事务传播级别一般不需要定义，默认就是PROPAGATION_REQUIRED，除非在嵌套事务的情况下需要重点了解。</p> <p>以上就是我对这个问题的理解！</p> <p><strong>面试点评</strong></p> <p>这个问题其实只需要理解事务传播行为的本质以及为什么需要考虑到事务传播的问题。</p> <p>就可以直接基于自身的技术积累来推演出答案，无非就是基于可能的策略进行穷举，怎么也能推演出5种吧。</p> <p>好的，本期的普通人VS高手面试系列的视频就到这里结束了。</p> <p>有任何不懂的技术面试题，欢迎随时私信我</p> <h2 id="为什么要使用spring-框架"><a href="#为什么要使用spring-框架" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/513193990" target="_blank" rel="noopener noreferrer">为什么要使用Spring 框架？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>Spring是一个轻量级应用框架，它提供了IoC和AOP这两个核心的功能。</p> <p>它的核心目的是为了简化企业级应用程序的开发，使得开发者只需要关心业务需求，不需要关心Bean的管理，</p> <p>以及通过切面增强功能减少代码的侵入性。</p> <p>从Spring本身的特性来看，我认为有几个关键点是我们选择Spring框架的原因。</p> <ul><li>轻量：Spring 是轻量的，基本的版本大约2MB。</li> <li>IOC/DI：Spring通过IOC容器实现了Bean的生命周期的管理，以及通过DI实现依赖注入，从而实现了对象依赖的松耦合管理。</li> <li>面向切面的编程(AOP)：Spring支持面向切面的编程，从而把应用业务逻辑和系统服务分开。</li> <li>MVC框架：Spring MVC提供了功能更加强大且更加灵活的Web框架支持</li> <li>事务管理：Spring通过AOP实现了事务的统一管理，对应用开发中的事务处理提供了非常灵活的支持</li></ul> <p>最后，Spring从第一个版本发布到现在，它的生态已经非常庞大了。在业务开发领域，Spring生态几乎提供了</p> <p>非常完善的支持，更重要的是社区的活跃度和技术的成熟度都非常高，以上就是我对这个问题的理解。</p> <p><img src="https://pic1.zhimg.com/v2-bd02289536cb822808d0adb77104874a_720w.jpg?source=d16d100b" alt="img"><img src="https://pic1.zhimg.com/80/v2-bd02289536cb822808d0adb77104874a_720w.jpg?source=d16d100b" alt="img"></p> <p><strong>总结</strong></p> <p>任何一个技术框架，一定是为了解决某些特定的问题，只是大家忽视了这个点。</p> <p>为什么要用，再往高一点来说，其实就是技术选型，能回答这个问题，</p> <p>意味着面对业务场景或者技术问题的解决方案上，会有自己的见解和思考。</p> <p>所以，我自己也喜欢在面试的时候问这一类的问题。</p> <p>本期的普通人VS高手面试系列就到这里结束了。</p> <p>有任何不懂的技术面试题，欢迎随时私信我</p> <h2 id="请简述一下伪共享的概念以及如何避免"><a href="#请简述一下伪共享的概念以及如何避免" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/512667754" target="_blank" rel="noopener noreferrer">请简述一下伪共享的概念以及如何避免<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>对于这个问题，要从几个方面来回答。</p> <p>首先，计算机工程师为了提高CPU的利用率，平衡CPU和内存之间的速度差异，在CPU里面设计了三级缓存。</p> <p>CPU在向内存发起IO操作的时候，一次性会读取64个字节的数据作为一个缓存行，缓存到CPU的高速缓存里面。</p> <p>在Java中一个long类型是8个字节，意味着一个缓存行可以存储8个long类型的变量。</p> <p>这个设计是基于空间局部性原理来实现的，也就是说，如果一个存储器的位置被引用，那么将来它附近的位置也会被引用。</p> <p>所以缓存行的设计对于CPU来说，可以有效的减少和内存的交互次数，从而避免了CPU的IO等待，以提升CPU的利用率。</p> <p>正是因为这种缓存行的设计，导致如果多个线程修改同一个缓存行里面的多个独立变量的时候，基于缓存一致性协议，就会无意中影响了彼此的性能，这就是伪共享的问题。</p> <p>像这样一种情况，CPU0上运行的线程想要更新变量X、CPU1上的线程想要更新变量Y，而X/Y/Z都在同一个缓存行里面。</p> <p><img src="https://pic1.zhimg.com/v2-9927cd7f26f8c57f6ad885ede60057e3_720w.jpg?source=d16d100b" alt="img"></p> <p>每个线程都需要去竞争缓存行的所有权对变量做更新，基于缓存一致性协议。</p> <p>一旦运行在某个CPU上的线程获得了所有权并执行了修改，就会导致其他CPU中的缓存行失效。</p> <p>这就是伪共享问题的原理。</p> <p>因为伪共享会问题导致缓存锁的竞争，所以在并发场景中的程序执行效率一定会收到较大的影响。</p> <p>这个问题的解决办法有两个：</p> <ol><li>使用对齐填充，因为一个缓存行大小是64个字节，如果读取的目标数据小于64个字节，可以增加一些无意义的成员变量来填充。</li> <li>在Java8里面，提供了@Contented注解，它也是通过缓存行填充来解决伪共享问题的，被@Contented注解声明的类或者字段，会被加载到独立的缓存行上。</li></ol> <p>已上就是我对这个问题的理解！</p> <p><strong>总结</strong></p> <p>在Netty里面，有大量用到对齐填充的方式来避免伪共享问题。</p> <p>所以这并不是一个所谓超纲的问题，在我看来，多线程也好、数据结构算法也好、还是JVM，这个一个</p> <p>合格的Java程序员必须要掌握的基础。</p> <p>我们习惯了在框架里面写代码，却忽略了各种成熟框架已经让Java程序员变得越来越普通。</p> <p>本期的普通人VS高手面试系列就到这里结束了。</p> <h2 id="怎么理解线程安全"><a href="#怎么理解线程安全" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/512123651" target="_blank" rel="noopener noreferrer">怎么理解线程安全？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>简单来说，在多个线程访问某个方法或者对象的时候，不管通过任何的方式调用以及线程如何去交替执行。</p> <p>在程序中不做任何同步干预操作的情况下，这个方法或者对象的执行/修改都能按照预期的结果来反馈，那么这个类就是线程安全的。</p> <p>实际上，线程安全问题的具体表现体现在三个方面，原子性、有序性、可见性。</p> <p>原子性呢，是指当一个线程执行一系列程序指令操作的时候，它应该是不可中断的，因为一旦出现中断，站在多线程的视角来看，这一系列的程序指令会出现前后执行结果不一致的问题。</p> <p>这个和数据库里面的原子性是一样的，简单来说就是一段程序只能由一个线程完整的执行完成，而不能存在多个线程干扰。</p> <p>CPU的上下文切换，是导致原子性问题的核心，而JVM里面提供了Synchronized关键字来解决原子性问题。</p> <p><img src="https://pic2.zhimg.com/v2-25f50556ea954c4ce177cc6015198126_720w.jpg?source=d16d100b" alt="img"></p> <p>可见性，就是说在多线程环境下，由于读和写是发生在不同的线程里面，有可能出现某个线程对共享变量的修改，对其他线程不是实时可见的。</p> <p>导致可见性问题的原因有很多，比如CPU的高速缓存、CPU的指令重排序、编译器的指令重排序。</p> <p>有序性，指的是程序编写的指令顺序和最终CPU运行的指令顺序可能出现不一致的现象，这种现象也可以称为指令重排序，所以有序性也会导致可见性问题。</p> <p>可见性和有序性可以通过JVM里面提供了一个Volatile关键字来解决。</p> <p>在我看来，导致有序性、原子性、可见性问题的本质，是计算机工程师为了最大化提升CPU利用率导致的。比如为了提升CPU利用率，设计了三级缓存、设计了StoreBuffer、设计了缓存行这种预读机制、在操作系统里面，设计了线程模型、在编译器里面，设计了编译器的深度优化机制。</p> <p>一上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>从高手的回答中，可以很深刻的感受到，他对于计算机底层原理和线程安全性相关的底层实现是理解得很透彻的。</p> <p>对我来说，这个人去写程序代码，不用担心他滥用线程导致一些不可预测的线程安全性问题了，这就是这个面试题的价值。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <h2 id="什么是双亲委派"><a href="#什么是双亲委派" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/511575528" target="_blank" rel="noopener noreferrer">什么是双亲委派？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>关于这个问题，需要从几个方面来回答。</p> <p>首先，我简单说一下类的加载机制，就是我们自己写的java源文件到最终运行，必须要经过编译和类加载两个阶段。</p> <p><img src="https://pica.zhimg.com/v2-fefdfa858f2f2baadccbcfb1f0e957a4_720w.jpg?source=d16d100b" alt="img"></p> <p>编译的过程就是把.java文件编译成.class文件。</p> <p>类加载的过程，就是把class文件装载到JVM内存中，装载完成以后就会得到一个Class对象，我们就可以使用new关键字来实例化这个对象。</p> <p>而类的加载过程，需要涉及到类加载器。</p> <p><img src="https://pic3.zhimg.com/v2-7c319af4e7a0f9ca4d92303094202ddc_720w.jpg?source=d16d100b" alt="img"></p> <p>JVM在运行的时候，会产生3个类加载器，这三个类加载器组成了一个层级关系</p> <p>每个类加载器分别去加载不同作用范围的jar包，比如</p> <ul><li>Bootstrap ClassLoader，主要是负责Java核心类库的加载，也就是 %{JDK_HOME}\lib下的rt.jar、resources.jar等</li> <li>Extension ClassLoader，主要负责%{JDK_HOME}\lib\ext目录下的jar包和class文件</li> <li>Application ClassLoader，主要负责当前应用里面的classpath下的所有jar包和类文件</li></ul> <p>除了系统自己提供的类加载器以外，还可以通过ClassLoader类实现自定义加载器，去满足一些特殊场景的需求。</p> <p>所谓的父委托模型，就是按照类加载器的层级关系，逐层进行委派。</p> <p><img src="https://pic3.zhimg.com/v2-7843c0a3be5b5149049e74aed56a539d_720w.jpg?source=d16d100b" alt="img"></p> <p>比如当需要加载一个class文件的时候，首先会把这个class的查询和加载委派给父加载器去执行，如果父加载器都无法加载，再尝试自己来加载这个class。</p> <p>这样设计的好处，我认为有几个。</p> <ol><li>安全性，因为这种层级关系实际上代表的是一种优先级，也就是所有的类的加载，优先给Bootstrap ClassLoader。那对于核心类库中的类，就没办法去破坏，比如自己写一个java.lang.String，最终还是会交给启动类加载器。再加上每个类加载器的作用范围，那么自己写的java.lang.String就没办法去覆盖类库中类。</li> <li>我认为这种层级关系的设计，可以避免重复加载导致程序混乱的问题，因为如果父加载器已经加载过了，那么子类就没必要去加载了。</li></ol> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>JVM虚拟机一定面试必问的领域，因为我们自己写的程序运行在JVM上，一旦出现问题，你不理解，就无法排查。</p> <p>就像一个修汽车的工人，他不知道汽车的工作原理，不懂发动机，那他是无法做好这份工作的。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，这些面试题我都整理成了笔记，大家有需要的可以私信获取。</p> <h2 id="什么是聚集索引和非聚集索引"><a href="#什么是聚集索引和非聚集索引" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/511140605" target="_blank" rel="noopener noreferrer">什么是聚集索引和非聚集索引<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ol><li>简单来说，聚集索引就是基于主键创建的索引，除了主键索引以外的其他索引，称为非聚集索引，也叫做二级索引。</li> <li>由于在InnoDB引擎里面，一张表的数据对应的物理文件本身就是按照B+树来组织的一种索引结构，而聚集索引就是按照每张表的主键来构建一颗B+树，然后叶子节点里面存储了这个表的每一行数据记录。</li> <li>所以基于InnoDB这样的特性，聚集索引并不仅仅是一种索引类型，还代表着一种数据的存储方式。</li> <li>同时也意味着每个表里面必须要有一个主键，如果没有主键，InnoDB会默认选择或者添加一个隐藏列作为主键索引来存储这个表的数据行。一般情况是建议使用自增id作为主键，这样的话id本身具有连续性使得对应的数据也会按照顺序存储在磁盘上，写入性能和检索性能都很高。否则，如果使用uuid这种随机id，那么在频繁插入数据的时候，就会导致随机磁盘IO，从而导致性能较低。</li> <li>需要注意的是，InnoDB里面只能存在一个聚集索引，原因很简单，如果存在多个聚集索引，那么意味着这个表里面的数据存在多个副本，造成磁盘空间的浪费，以及数据维护的困难。</li> <li>由于在InnoDB里面，主键索引表示的是一种数据存储结构，所以如果是基于非聚集索引来查询一条完整的记录，最终还是需要访问主键索引来检索。</li></ol> <p><img src="https://pic3.zhimg.com/v2-704fc322c9958893d2c29fe5e0431619_720w.jpg?source=d16d100b" alt="img"></p> <p><strong>总结</strong></p> <p>这个问题要回答好，还真不容易。涉及到Mysql里面索引的实现原理。</p> <p>但是如果回答好了，就能够很好的反馈求职者的技术功底，那通过面试就比较容易了。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，这些面试题我都整理成了笔记，大家有需要的可以私信获取。</p> <h2 id="基于数组的阻塞队列arrayblockingqueue原理"><a href="#基于数组的阻塞队列arrayblockingqueue原理" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/510838318" target="_blank" rel="noopener noreferrer">基于数组的阻塞队列ArrayBlockingQueue原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>1.阻塞队列（BlockingQueue）是在队列的基础上增加了两个附加操作</p> <p><img src="https://pic3.zhimg.com/v2-7a9b503be0c04372fda7927f2c62d7bc_720w.jpg?source=d16d100b" alt="img"><img src="https://pic3.zhimg.com/80/v2-7a9b503be0c04372fda7927f2c62d7bc_720w.jpg?source=d16d100b" alt="img"></p> <ul><li>在队列为空的时候，获取元素的线程会等待队列变为非空。</li> <li>当队列满时，存储元素的线程会等待队列可用。</li></ul> <p>2.由于阻塞队列的特性，可以非常容易实现生产者消费者模型，也就是生产者只需要关心数据的生产，消费者只需要关注数据的消费，所以如果队列满了，生产者就等待，同样，队列空了，消费者也需要等待。</p> <p>3.要实现这样的一个阻塞队列，需要用到两个关键的技术，队列元素的存储、以及线程阻塞和唤醒。</p> <p>4.而ArrayBlockingQueue是基于数组结构的阻塞队列，也就是队列元素是存储在一个数组结构里面，并且由于数组有长度限制，为了达到循环生产和循环消费的目的，ArrayBlockingQueue用到了循环数组。</p> <p>5.而线程的阻塞和唤醒，用到了J.U.C包里面的ReentrantLock和Condition。 Condition相当于wait/notify在JUC包里面的实现。</p> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>对于原理类的问题，有些小伙伴找不到切入点，不知道该怎么回答。</p> <p>所谓的原理，通常说的是工作原理，比如对于ArrayBlockingQueue这个问题。</p> <p>它的作用是在队列的基础上提供了阻塞添加和获取元素的能力，那么它的工作原理就是指用了什么设计方法或者技术来实现这样的功能，我们只要把这个部分说清楚就可以了。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，这些面试题我都整理成了笔记，大家有需要的可以私信获取。</p> <h2 id="threadlocal是什么-它的实现原理呢"><a href="#threadlocal是什么-它的实现原理呢" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/510073116" target="_blank" rel="noopener noreferrer">ThreadLocal是什么？它的实现原理呢？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，这个问题我从三个方面来回答。</p> <p>1.ThreadLocal是一种线程隔离机制，它提供了多线程环境下对于共享变量访问的安全性。</p> <p>2.在多线程访问共享变量的场景中，一般的解决办法是对共享变量加锁，从而保证在同一时刻只有一个线程能够对共享变量进行更新，并且基于Happens-Before规则里面的监视器锁规则，又保证了数据修改后对其他线程的可见性。</p> <p><img src="https://pica.zhimg.com/v2-170a1c51ff3a429292a3c0a71edc0a72_720w.png?source=d16d100b" alt="img"><img src="https://pica.zhimg.com/80/v2-170a1c51ff3a429292a3c0a71edc0a72_720w.png?source=d16d100b" alt="img"></p> <p><img src="https://pic1.zhimg.com/v2-65fbd3811a0b8fd0f2affcf5c7af3a81_720w.jpg?source=d16d100b" alt="img"></p> <p>3.但是加锁会带来性能的下降，所以ThreadLocal用了一种空间换时间的设计思想，也就是说在每个线程里面，都有一个容器来存储共享变量的副本，然后每个线程只对自己的变量副本来做更新操作，这样既解决了线程安全问题，又避免了多线程竞争加锁的开销。</p> <p><img src="https://pica.zhimg.com/v2-f811c7353959785a4e2c0bf639a65344_720w.jpg?source=d16d100b" alt="img"></p> <p>4.ThreadLocal的具体实现原理是，在Thread类里面有一个成员变量ThreadLocalMap，它专门来存储当前线程的共享变量副本，后续这个线程对于共享变量的操作，都是从这个ThreadLocalMap里面进行变更，不会影响全局共享变量的值。</p> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>ThreadLocal使用场景比较多，比如在数据库连接的隔离、对于客户端请求会话的隔离等等。</p> <p>在ThreadLocal中，除了空间换时间的设计思想以外，还有一些比较好的设计思想，比如线性探索解决hash冲突，数据预清理机制、弱引用key设计尽可能避免内存泄漏等。</p> <p>这些思想在解决某些类似的业务问题时，都是可以直接借鉴的。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，这些面试题我都整理成了笔记，大家有需要的可以私信获取。</p> <h2 id="讲一下wait和notify这个为什么要在synchronized代码块中"><a href="#讲一下wait和notify这个为什么要在synchronized代码块中" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/509577394" target="_blank" rel="noopener noreferrer">讲一下wait和notify这个为什么要在synchronized代码块中？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ol><li>wait和notify用来实现多线程之间的协调，wait表示让线程进入到阻塞状态，notify表示让阻塞的线程唤醒。</li> <li>wait和notify必然是成对出现的，如果一个线程被wait()方法阻塞，那么必然需要另外一个线程通过notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</li> <li>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程t1修改共享变量s，线程t2获取修改后的共享变量s，从而完成数据通信。
但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程t2在访问共享变量s之前，必须要知道线程t1已经修改过了共享变量s，否则就需要等待。
同时，线程t1修改过了共享变量S之后，还需要通知在等待中的线程t2。
所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线程在什么条件下等待，什么条件下唤醒。</li></ol> <p><img src="https://pica.zhimg.com/v2-002c9d484a5ea4127fef78ae6f461a66_720w.jpg?source=d16d100b" alt="img"></p> <p>4.而Synchronized同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。</p> <p>5.所以这也是为什么wait/notify需要放在Synchronized同步代码块中的原因，有了Synchronized同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。</p> <p>6.另外，为了避免wait/notify的错误使用，jdk强制要求把wait/notify写在同步代码块里面，否则会抛出IllegalMonitorStateException</p> <p>7.最后，基于wait/notify的特性，非常适合实现生产者消费者的模型，比如说用wait/notify来实现连接池就绪前的等待与就绪后的唤醒。</p> <p>以上就是我对wait/notify这个问题的理解。</p> <p><strong>总结</strong></p> <p>这个是一个典型的经典面试题。</p> <p>其实考察的就是Synchronized、wait/notify的设计原理和实现原理。</p> <p>由于wait/notify在业务开发整几乎不怎么用到，所以大部分人回答不出来。</p> <p>其实并发这块内容理论上来说所有程序员都应该要懂，不管是它的应用价值，还是设计理念，非常值得学习和借鉴。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，有任何技术上的问题，职业发展有关的问题，都可以私信我，我会在第一时间回复。</p> <h2 id="说说缓存雪崩和缓存穿透的理解-以及如何避免"><a href="#说说缓存雪崩和缓存穿透的理解-以及如何避免" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/507358221" target="_blank" rel="noopener noreferrer">说说缓存雪崩和缓存穿透的理解，以及如何避免？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>缓存雪崩，就是存储在缓存里面的大量数据，在同一个时刻全部过期，</p> <p>原本缓存组件抗住的大部分流量全部请求到了数据库。</p> <p>导致数据库压力增加造成数据库服务器崩溃的现象。</p> <p><img src="https://pic1.zhimg.com/v2-caa7604a20f04667761fe108cdfcdcc8_720w.jpg?source=d16d100b" alt="img"></p> <p>导致缓存雪崩的主要原因，我认为有两个：</p> <ol><li>缓存中间件宕机，当然可以对缓存中间件做高可用集群来避免。</li> <li>缓存中大部分key都设置了相同的过期时间，导致同一时刻这些key都过期了。对于这样的情况，可以在失效时间上增加一个1到5分钟的随机值。</li></ol> <p>缓存穿透问题，表示是短时间内有大量的不存在的key请求到应用里面，而这些不存在的key在缓存里面又找不到，从而全部穿透到了数据库，造成数据库压力。</p> <p>我认为这个场景的核心问题是针对缓存的一种攻击行为，因为在正常的业务里面，即便是出现了这样的情况，由于缓存的不断预热，影响不会很大。</p> <p>而攻击行为就需要具备时间是的持续性，而只有key确实在数据库里面也不存在的情况下，才能达到这个目的，所以，我认为有两个方法可以解决：</p> <ol><li>把无效的key也保存到Redis里面，并且设置一个特殊的值，比如“null”，这样的话下次再来访问，就不会去查数据库了。</li> <li>但是如果攻击者不断用随机的不存在的key来访问，也还是会存在问题，所以可以用布隆过滤器来实现，在系统启动的时候把目标数据全部缓存到布隆过滤器里面，当攻击者用不存在的key来请求的时候，先到布隆过滤器里面查询，如果不存在，那意味着这个key在数据库里面也不存在。
布隆过滤器还有一个好处，就是它采用了bitmap来进行数据存储，占用的内存空间很少。</li></ol> <p><img src="https://pic1.zhimg.com/v2-3c6cae7978fdbf4da6af742b7646897d_720w.jpg?source=d16d100b" alt="img"></p> <p>不过，在我看来，您提出来的这个问题，有点过于放大了它带来的影响。</p> <p>首先，在一个成熟的系统里面，对于比较重要的热点数据，必然会有一个专门缓存系统来维护，同时它的过期时间的维护必然和其他业务的key会有一定的差别。而且非常重要的场景，我们还会设计多级缓存系统。</p> <p>其次，即便是触发了缓存雪崩，数据库本身的容灾能力也并没有那么脆弱，数据库的主从、双主、读写分离这些策略都能够很好的缓解并发流量。</p> <p>最后，数据库本身也有最大连接数的限制，超过限制的请求会被拒绝，再结合熔断机制，也能够很好的保护数据库系统，最多就是造成部分用户体验不好。</p> <p>另外，在程序设计上，为了避免缓存未命中导致大量请求穿透到数据库的问题，还可以在访问数据库这个环节加锁。虽然影响了性能，但是对系统是安全的。</p> <p><img src="https://pic2.zhimg.com/v2-f7232ca8b78e2c13c25fc4df92488f37_720w.jpg?source=d16d100b" alt="img"></p> <p>总而言之，我认为解决的办法很多，具体选择哪种方式，还是看具体的业务场景。</p> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>我发现现在很多面试，真的是为了面试而面试，要么就是在网上摘题，要么就是不断的问一些无关痛痒的问题。</p> <p>至于最终面试官怎么判断你是否合适，咱也不知道，估计就是有些小伙伴说的，看长相，看眼缘！</p> <p>我认为一个合格的面试官，他必须要具备非常深厚的技术功底。</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，有任何技术上的问题，职业发展有关的问题，都可以私信我，我会在第一时间回复。</p> <h2 id="volatile关键字有什么用-它的实现原理是什么"><a href="#volatile关键字有什么用-它的实现原理是什么" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/506753931" target="_blank" rel="noopener noreferrer">volatile关键字有什么用？它的实现原理是什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>volatile关键字有两个作用。</p> <ol><li>可以保证在多线程环境下共享变量的可见性。</li> <li>通过增加内存屏障防止多个指令之间的重排序。</li></ol> <p>我理解的可见性，是指当某一个线程对共享变量的修改，其他线程可以立刻看到修改之后的值。</p> <p>其实这个可见性问题，我认为本质上是由几个方面造成的。</p> <p>1.CPU层面的高速缓存，在CPU里面设计了三级缓存去解决CPU运算效率和内存IO效率问题，但是带来的就是缓存的一致性问题，而在多线程并行执行的情况下，缓存一致性就会导致可见性问题。</p> <p><img src="https://pic1.zhimg.com/v2-19a30dbea7c98fbe56580fbff830da59_720w.jpg?source=d16d100b" alt="img"></p> <p>所以，对于增加了volatile关键字修饰的共享变量，JVM虚拟机会自动增加一个#Lock汇编指令，这个指令会根据CPU型号自动添加总线锁或/缓存锁
我简单说一下这两种锁，</p> <ul><li><ul><li>总线锁是锁定了CPU的前端总线，从而导致在同一时刻只能有一个线程去和内存通信，这样就避免了多线程并发造成的可见性。</li> <li>缓存锁是对总线锁的优化，因为总线锁导致了CPU的使用效率大幅度下降，所以缓存锁只针对CPU三级缓存中的目标数据加锁，缓存锁是使用MESI缓存一致性来实现的。</li></ul></li></ul> <p>2.指令重排序，所谓重排序，就是指令的编写顺序和执行顺序不一致，在多线程环境下导致可见性问题。指令重排序本质上是一种性能优化的手段，它来自于几个方面。</p> <ul><li><ul><li>CPU层面，针对MESI协议的更进一步优化去提升CPU的利用率，引入了StoreBuffer机制，而这一种优化机制会导致CPU的乱序执行。当然为了避免这样的问题，CPU提供了内存屏障指令，上层应用可以在合适的地方插入内存屏障来避免CPU指令重排序问题。</li> <li>编译器的优化，编译器在编译的过程中，在不改变单线程语义和程序正确性的前提下，对指令进行合理的重排序优化来提升性能。</li></ul></li></ul> <p>所以，如果对共享变量增加了volatile关键字，那么在编译器层面，就不会去触发编译器优化，同时再JVM里面，会插入内存屏障指令来避免重排序问题。</p> <p>当然，除了volatile以外，从JDK5开始，JMM就使用了一种Happens-Before模型去描述多线程之间的内存可见性问题。</p> <p>如果两个操作之间具备Happens-Before关系，那么意味着这两个操作具备可见性关系，不需要再额外去考虑增加volatile关键字来提供可见性保障。</p> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>在我看来，并发编程是每个程序员必须要掌握好的领域，它里面涵盖的设计思想、和并发问题的解决思路、以及作为一个并发工具，都是非常值得深度研究的。</p> <p>我推荐大家去读一下《Java并发编程深度解析与原理实战》这本书，对Java并发这块的内容描述得很清晰。</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，有任何技术上的问题，职业发展有关的问题，都可以私信我，我会在第一时间回复。</p> <h2 id="请说一下你对分布式锁的理解-以及分布式锁的实现"><a href="#请说一下你对分布式锁的理解-以及分布式锁的实现" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/506131939" target="_blank" rel="noopener noreferrer">请说一下你对分布式锁的理解，以及分布式锁的实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>分布式锁，是一种跨进程的跨机器节点的互斥锁，它可以用来保证多机器节点对于共享资源访问的排他性。</p> <p><img src="https://pic1.zhimg.com/v2-4bd76d3b276437fb996c2830d96a4437_720w.jpg?source=d16d100b" alt="img"></p> <p>我觉得分布式锁和线程锁本质上是一样的，线程锁的生命周期是单进程多线程，分布式锁的声明周期是多进程多机器节点。</p> <p>在本质上，他们都需要满足锁的几个重要特性：</p> <ul><li>排他性，也就是说，同一时刻只能有一个节点去访问共享资源。</li> <li>可重入性，允许一个已经获得锁的进程，在没有释放锁之前再次重新获得锁。</li> <li>锁的获取、释放的方法</li> <li>锁的失效机制，避免死锁的问题</li></ul> <p>所以，我认为，只要能够满足这些特性的技术组件都能够实现分布式锁。</p> <ol><li>关系型数据库，可以使用唯一约束来实现锁的排他性，
如果要针对某个方法加锁，就可以创建一个表包含方法名称字段，
并且把方法名设置成唯一的约束。
那抢占锁的逻辑就是：往表里面插入一条数据，如果已经有其他的线程获得了某个方法的锁，那这个时候插入数据会失败，从而保证了互斥性。
这种方式虽然简单啊，但是要实现比较完整的分布式锁，还需要考虑重入性、锁失效机制、没抢占到锁的线程要实现阻塞等，就会比较麻烦。</li> <li>Redis，它里面提供了SETNX命令可以实现锁的排他性，当key不存在就返回1，存在就返回0。然后还可以用expire命令设置锁的失效时间，从而避免死锁问题。
当然有可能存在锁过期了，但是业务逻辑还没执行完的情况。 所以这种情况，可以写一个定时任务对指定的key进行续期。
Redisson这个开源组件，就提供了分布式锁的封装实现，并且也内置了一个Watch Dog机制来对key做续期。
我认为Redis里面这种分布式锁设计已经能够解决99%的问题了，当然如果在Redis搭建了高可用集群的情况下出现主从切换导致key失效，这个问题也有可能造成
多个线程抢占到同一个锁资源的情况，所以Redis官方也提供了一个RedLock的解决办法，但是实现会相对复杂一些。</li> <li>在我看来，分布式锁应该是一个CP模型，而Redis是一个AP模型，所以在集群架构下由于数据的一致性问题导致极端情况下出现多个线程抢占到锁的情况很难避免。
那么基于CP模型又能实现分布式锁特性的组件，我认为可以选择Zookeeper或者etcd，</li></ol> <ul><li>在数据一致性方面，zookeeper用到了zab协议来保证数据的一致性，etcd用到了raft算法来保证数据一致性。</li> <li>在锁的互斥方面，zookeeper可以基于有序节点再结合Watch机制实现互斥和唤醒，etcd可以基于Prefix机制和Watch实现互斥和唤醒。</li></ul> <p>以上就是我对于分布式锁的理解！</p> <p>总结</p> <p>我认为，回答这个问题的核心本质，还是在技术底层深度理解的基础上的思考。</p> <p>可以从高手的回答中明显感受到，对于排它锁底层逻辑的理解是很深刻的，同时再技术的广度上也是有足够的积累。</p> <p>所以在回答的时候，面试官可以去抓到求职者在回答这个问题的时候的技术关键点和技术思维。</p> <p>我认为，当具备体系化的技术能力的时候，是很容易应对各种面试官的各种刁难的。</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞和收藏。</p> <p>另外，有任何技术上的问题，职业发展有关的问题，都可以私信我，我会在第一时间回复。</p> <h2 id="死锁的发生原因和怎么避免"><a href="#死锁的发生原因和怎么避免" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/505200488" target="_blank" rel="noopener noreferrer">死锁的发生原因和怎么避免<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>死锁，简单来说就是两个或者两个以上的线程在执行的过程中，争夺同一个共享资源造成的相互等待的现象。</p> <p><img src="https://pic3.zhimg.com/v2-cb183d162325bc6bcea9906b2b51428a_b.jpg" alt="img"></p> <p>如果没有外部干预，线程会一直阻塞无法往下执行，这些一直处于相互等待资源的线程就称为死锁线程。</p> <p>导致死锁的条件有四个，也就是这四个条件同时满足就会产生死锁。</p> <ul><li>互斥条件，共享资源 X 和 Y 只能被一个线程占用；</li> <li>请求和保持条件，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li> <li>不可抢占条件，其他线程不能强行抢占线程 T1 占有的资源；</li> <li>循环等待条件，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ul> <p>导致死锁之后，只能通过人工干预来解决，比如重启服务，或者杀掉某个线程。</p> <p>所以，只能在写代码的时候，去规避可能出现的死锁问题。</p> <p>按照死锁发生的四个条件，只需要破坏其中的任何一个，就可以解决，但是，互斥条件是没办法破坏的，因为这是互斥锁的基本约束，其他三方条件都有办法来破坏：</p> <ul><li>对于“请求和保持”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li> <li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li> <li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ul> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>发现了吗？ 当大家理解了死锁发生的条件，那么对于这些条件的破坏，</p> <p>是可以通过自己的技术积累，来设计解决方法的。</p> <p>所有的技术思想和技术架构，都是由人来设计的，为什么别人能够设计？</p> <p>本质上，还是技术积累后的结果！越是底层的设计，对于知识面的要求就越多。</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。</p> <h2 id="spring-boot中自动装配机制的原理"><a href="#spring-boot中自动装配机制的原理" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/504702812" target="_blank" rel="noopener noreferrer">Spring Boot中自动装配机制的原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>自动装配，简单来说就是自动把第三方组件的Bean装载到Spring IOC器里面，不需要开发人员再去写Bean的装配配置。</p> <p>在Spring Boot应用里面，只需要在启动类加上@SpringBootApplication注解就可以实现自动装配。</p> <p>@SpringBootApplication是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。</p> <p><img src="https://pic3.zhimg.com/v2-8b03c5c8fc5c296ab940d8120b39243c_720w.jpg?source=d16d100b" alt="img"></p> <p>自动装配的实现主要依靠三个核心关键技术。</p> <ol><li>引入Starter启动依赖组件的时候，这个组件里面必须要包含@Configuration配置类，在这个配置类里面通过@Bean注解声明需要装配到IOC容器的Bean对象。</li> <li>这个配置类是放在第三方的jar包里面，然后通过SpringBoot中的约定优于配置思想，把这个配置类的全路径放在classpath:/META-INF/spring.factories文件中。这样SpringBoot就可以知道第三方jar包里面的配置类的位置，这个步骤主要是用到了Spring里面的SpringFactoriesLoader来完成的。</li> <li>SpringBoot拿到所第三方jar包里面声明的配置类以后，再通过Spring提供的ImportSelector接口，实现对这些配置类的动态加载。</li></ol> <p>在我看来，SpringBoot是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。</p> <p>其实，自动装配的思想，在SpringFramework3.x版本里面的@Enable注解，就有了实现的雏形。@Enable注解是模块驱动的意思，我们只需要增加某个@Enable注解，就自动打开某个功能，而不需要针对这个功能去做Bean的配置，@Enable底层也是帮我们去自动完成这个模块相关Bean的注入。</p> <p>以上，就是我对Spring Boot自动装配机制的理解。</p> <p>总结</p> <p>发现了吗？高手和普通人的回答，并不是回答的东西多和少。</p> <p>而是让面试官看到你对于这个技术领域的理解深度和自己的见解，从而让面试官在一大堆求职者中，对你产生清晰的印象。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。</p> <h2 id="redis和mysql如何保证数据一致性"><a href="#redis和mysql如何保证数据一致性" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/504105962" target="_blank" rel="noopener noreferrer">Redis和Mysql如何保证数据一致性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>一般情况下，Redis用来实现应用和数据库之间读操作的缓存层，主要目的是减少数据库IO，还可以提升数据的IO性能。</p> <p>这是它的整体架构。</p> <p>当应用程序需要去读取某个数据的时候，首先会先尝试去Redis里面加载，如果命中就直接返回。如果没有命中，就从数据库查询，查询到数据后再把这个数据缓存到Redis里面。</p> <p><img src="https://pic3.zhimg.com/v2-f4875c574723f3ad5d2239f5aa1a7f31_720w.jpg?source=d16d100b" alt="img"></p> <p>在这样一个架构中，会出现一个问题，就是一份数据，同时保存在数据库和Redis里面，当数据发生变化的时候，需要同时更新Redis和Mysql，由于更新是有先后顺序的，并且它不像Mysql中的多表事务操作，可以满足ACID特性。所以就会出现数据一致性问题。</p> <p><img src="https://pic2.zhimg.com/v2-0c9a1fdddd6402030f2f226afde16559_720w.jpg?source=d16d100b" alt="img"></p> <p>在这种情况下，能够选择的方法只有几种。</p> <ol><li>先更新数据库，再更新缓存</li> <li>先删除缓存，再更新数据库</li></ol> <p>如果先更新数据库，再更新缓存，如果缓存更新失败，就会导致数据库和Redis中的数据不一致。</p> <p><img src="https://pic2.zhimg.com/v2-b2b32c658bc55b69967e55f6bbf8c4a4_720w.jpg?source=d16d100b" alt="img"><img src="https://pic2.zhimg.com/80/v2-b2b32c658bc55b69967e55f6bbf8c4a4_720w.jpg?source=d16d100b" alt="img"></p> <p>如果是先删除缓存，再更新数据库，理想情况是应用下次访问Redis的时候，发现Redis里面的数据是空的，就从数据库加载保存到Redis里面，那么数据是一致的。但是在极端情况下，由于删除Redis和更新数据库这两个操作并不是原子的，所以这个过程如果有其他线程来访问，还是会存在数据不一致问题。</p> <p><img src="https://pic3.zhimg.com/v2-813f9831c16fc331b7cd5f84e09dac7f_720w.jpg?source=d16d100b" alt="img"></p> <p>所以，如果需要在极端情况下仍然保证Redis和Mysql的数据一致性，就只能采用最终一致性方案。</p> <p>比如基于RocketMQ的可靠性消息通信，来实现最终一致性。</p> <p><img src="https://pic2.zhimg.com/v2-e465cedf902998c398f615e779c8de1d_720w.jpg?source=d16d100b" alt="img"></p> <p>还可以直接通过Canal组件，监控Mysql中binlog的日志，把更新后的数据同步到Redis里面。</p> <p><img src="https://pic2.zhimg.com/v2-7d4e5df6dfe28d5289ca071735e3880e_720w.jpg?source=d16d100b" alt="img"></p> <p>因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那就不能使用这个方案来做。</p> <p>以上就是我对这个问题的理解。</p> <p><strong>总结</strong></p> <p>在面试的时候，面试官喜欢问各种没有场景化的纯粹的技术问题，比如说：“你这个最终一致性方案”还是会存在数据不一致的问题啊？那怎么解决？</p> <p>先不用慌，技术是为业务服务的，所以不同的业务场景，对于技术的选择和方案的设计都是不同的，所以这个时候，可以反问面试官，具体的业务场景是什么？</p> <p>一定要知道的是，一个技术方案不可能cover住所有的场景，明白了吗？</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。</p> <p>另外，最近从评论区收到的面试问题，都有点太泛了，比如：说一下mongoDB啊，说一下kafka啊、说一下并发啊，这些问题都是要几个小时才能彻底说清楚，建议大家提具体一点的问题。</p> <h2 id="什么是服务网格"><a href="#什么是服务网格" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/503522111" target="_blank" rel="noopener noreferrer">什么是服务网格？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>服务网格，也就是Service Mesh，它是专门用来处理服务通讯的基础设施层。它的主要功能是处理服务之间的通信，并且负责实现请求的可靠性传递。</p> <p>Service Mesh，我们通常把他称为第三代微服务架构，既然是第三代，那么意味着他是在原来的微服务架构下做的升级。</p> <p>为了更好的说明Service Mesh，那我就不得不说一下微服务架构部分的东西。</p> <p>首先，当我们把一个电商系统以微服务化架构进行拆分后，会的到这样的一个架构（如图），其中包括Webserver、payment、inventory等等。</p> <p><img src="https://pic3.zhimg.com/v2-be3897c66d63dc6546e668f9eed399d6_720w.jpg?source=d16d100b" alt="img"></p> <p>（如图）这些微服务应用，会被部署到Docker容器、或者Kubernetes集群。由于每个服务的业务逻辑是独立的，比如payment会实现支付的业务逻辑、order实现订单的处理、Webserver实现客户端请求的响应等。</p> <p><img src="https://pic2.zhimg.com/v2-5cd2c6904c59f3a71166f9b76c699c4b_720w.jpg?source=d16d100b" alt="img"></p> <p>（如图）所以，服务之间必须要相互通信，才能实现功能的完整性。比如用户把一个商品加入购物车，请求会进入到Webserver，然后转发到shopping cart进行处理，并存到数据库。</p> <p><img src="https://pic3.zhimg.com/v2-2c6173c648ef3d054726f5d7fb36c439_720w.jpg?source=d16d100b" alt="img"></p> <p>而在这个过程中，每个服务之间必须要知道对方的通信地址，并且当有新的节点加入进来的时候，还需要对这些通信地址进行动态维护。所以，在第一代微服务架构中，每个微服务除了要实现业务逻辑以外，还需要解决上下游寻址、通讯、以及容错等问题。</p> <p>（如图）于是，在第二代微服务架构下，引入了服务注册中心来实现服务之间的寻址，并且服务之间的容错机制、负载均衡也逐步形成了独立的服务框架，比如主流的Spring Cloud、或者Spring Cloud Alibaba。</p> <p><img src="https://pic1.zhimg.com/v2-04ff986b27c23bb53e7cf8e8a7706d0f_720w.jpg?source=d16d100b" alt="img"></p> <p>在第二代微服务架构中，负责业务开发的小伙伴不仅仅需要关注业务逻辑，还需要花大量精力去处理微服务中的一些基础性配置工作，虽然Spring Cloud已经尽可能去完成了这些事情，但对于开发人员来说，学习Spring Cloud，以及针对Spring Cloud的配置和维护，仍然存在较大的挑战。另外呢，也增加了整个微服务的复杂性。</p> <p>实际上，在我看来，“微服务中所有的这些服务注册、容错、重试、安全等工作，都是为了保证服务之间通信的可靠性”。</p> <p>于是，就有了第三代微服务架构，Service Mesh。</p> <p>（如图）原本模块化到微服务框架里的微服务基础能力，被进一步的从一个SDK中演进成了一个独立的代理进程-SideCar</p> <p>SideCar的主要职责就是负责各个微服务之间的通信，承载了原本第二代微服务架构中的服务发现、调用容错、服务治理等功能。使得微服务基础能力和业务逻辑迭代彻底解耦。</p> <p><img src="https://pic2.zhimg.com/v2-1e0fdd7fee60899e096d0ba54432ddb5_720w.jpg?source=d16d100b" alt="img"></p> <p>之所以我们称Service Mesh为服务网格，是因为在大规模微服务架构中，每个服务的通信都是由SideCar来代理的，各个服务之间的通信拓扑图，看起来就像一个网格形状（如图）。</p> <p>Istio是目前主流的Service Mesh开源框架。</p> <p>以上就是我对服务网格的理解。</p> <p><strong>结尾</strong></p> <p>Service Mesh架构其实就是云原生时代的微服务架构，对于大部分企业来说，仍然是处在第二代微服务架构下。</p> <p>所以，很多小伙伴不一定能够知道。</p> <p>不过，技术是在快速迭代的，有一句话叫“时代抛弃你的时候，连一句再见也不会说”，就像有些人在外包公司干了10多年</p> <p>再出来面试，发现很多公司要求的技术栈，他都不会。所以，建议大家要时刻刷新自己的能力，保持竞争优势！</p> <p>好的，本期的普通人VS高手面试系列的视频就到这里结束了，喜欢的朋友记得点赞收藏。</p> <p>我是Mic，一个工作了14年的Java程序员，咱们下期再见。</p> <h2 id="请说一下网络四元组"><a href="#请说一下网络四元组" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/503073419" target="_blank" rel="noopener noreferrer">请说一下网络四元组<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>四元组，简单理解就是在TCP协议中，去确定一个客户端连接的组成要素，它包括源IP地址、目标IP地址、源端口号、目标端口号。</p> <p>正常情况下，我们对于网络通信的认识可能是这样</p> <p><img src="https://pica.zhimg.com/v2-77ff4468204b1e9f40ff77d490c558ed_720w.jpg?source=d16d100b" alt="img"></p> <p>服务端通过ServerSocket建立一个对指定端口号的监听，比如8080。 客户端通过目标ip和端口就可以和服务端建立一个连接，然后进行数据传输。</p> <p>但是我们知道的是，一个Server端可以接收多个客户端的连接，比如像这种情况</p> <p><img src="https://pic3.zhimg.com/v2-0370cc662860d96f4956985beeed5270_720w.jpg?source=d16d100b" alt="img"></p> <p>那，当多个客户端连接到服务端的时候，服务端需要去识别每一个连接。</p> <p>并且TCP是全双工协议，也就是说数据允许在连接的两个方向上同时传输，因此这里的客户端，如果是反向通信，它又变成了服务端。</p> <p><img src="https://pic3.zhimg.com/v2-cbf26e014d74b3b6bb08ce2e2b2e4d85_720w.jpg?source=d16d100b" alt="img"></p> <p>所以基于这两个原因，就引入了四元组的设计，也就是说，当一个客户端和服务端建立一个TCP连接的时候，通过源IP地址、目标IP地址、源端口号、目标端口号来确定一个唯一的TCP连接。因为服务器的IP和端口是不变的，只要客户端的IP和端口彼此不同就OK了。</p> <p>比如像这种情况</p> <p><img src="https://pica.zhimg.com/v2-2dbff1d6e1c1f51ae7581d95f9d671bd_720w.jpg?source=d16d100b" alt="img"></p> <p>同一个客户端主机上有三个连接连到Server端，那么这个时候源IP相同，源端口号不同。此时建立的四元组就是（10.23.15.3，59461 ， 192.168.8.135，8080）</p> <p>其中，源端口号是每次建立连接的时候系统自动分配的。</p> <p>以上就是我对于四元组的理解。</p> <p>总结</p> <p>网络部分的知识，可能大家作为一个CURD工程师，觉得没必要去理解。</p> <p>但是未来呢？至少国内没有条件允许大家做一辈子CRUD，所以建议大家要“终局思维”来看待自己的职业规划。</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。</p> <h2 id="能谈一下cas机制吗"><a href="#能谈一下cas机制吗" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/502546104" target="_blank" rel="noopener noreferrer">能谈一下CAS机制吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>CAS是Java中Unsafe类里面的方法，它的全称是CompareAndSwap，比较并交换的意思。它的主要功能是能够保证在多线程环境下，对于共享变量的修改的原子性。</p> <p>我来举个例子，比如说有这样一个场景有一个成员变量state，默认值是0。</p> <p><img src="https://pic2.zhimg.com/v2-a9c8118809b6c9db78206b06387f3cad_720w.jpg?source=d16d100b" alt="img"></p> <p>定义了一个方法 <code>doSomething()</code>，这个方法的逻辑是，判断state是否为0 ，如果为0，就修改成1。</p> <p>这个逻辑看起来没有任何问题，但是在多线程环境下，会存在原子性的问题，因为这里是一个典型的，Read - Write的操作。</p> <p>一般情况下，我们会在doSomething()这个方法上加同步锁来解决原子性问题。</p> <p>但是，加同步锁，会带来性能上的损耗，所以，对于这类场景，我们就可以使用CAS机制来进行优化</p> <p>这个是优化之后的代码</p> <p><img src="https://pica.zhimg.com/v2-63ccb4ba654b160fa91e7b82d49ffacf_720w.jpg?source=d16d100b" alt="img"></p> <p>在doSomething()方法中，我们调用了unsafe类中的compareAndSwapInt()方法来达到同样的目的，这个方法有四个参数，</p> <p>分别是：当前对象实例、成员变量state在内存地址中的偏移量、预期值0、期望更改之后的值1。</p> <p>CAS机制会比较state内存地址偏移量对应的值和传入的预期值0是否相等，如果相等，就直接修改内存地址中state的值为1。</p> <p>否则，返回false，表示修改失败，而这个过程是原子的，不会存在线程安全问题。</p> <p>CompareAndSwap是一个native方法，实际上它最终还是会面临同样的问题，就是先从内存地址中读取state的值，然后去比较，最后再修改。</p> <p>这个过程不管是在什么层面上实现，都会存在原子性问题。</p> <p>所以呢，CompareAndSwap的底层实现中，在多核CPU环境下，会增加一个Lock指令对缓存或者总线加锁，从而保证比较并替换这两个指令的原子性。</p> <p>CAS主要用在并发场景中，比较典型的使用场景有两个。</p> <ol><li>第一个是J.U.C里面Atomic的原子实现，比如AtomicInteger，AtomicLong。</li> <li>第二个是实现多线程对共享资源竞争的互斥性质，比如在AQS、ConcurrentHashMap、ConcurrentLinkedQueue等都有用到。</li></ol> <p>以上就是我对这个问题的理解。</p> <p>总结</p> <p>最近大家也发现了我的文章内容在高手回答部分的变化。</p> <p>有些小伙伴说，你面试怎么还能带图来，明显作弊啊。</p> <p>其实主要是最近很多的面试题都偏底层，而底层的内容涵盖的知识面比较广，大家平时几乎没有接触过。</p> <p>所以，如果我想要去把这些知识传递给大家，就得做很多的图形和内容结构的设计，否则大家看完之后还是一脸懵逼。</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。</p> <h2 id="b树和b-树的理解"><a href="#b树和b-树的理解" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/501919360" target="_blank" rel="noopener noreferrer">b树和b+树的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>为了更清晰的解答这个问题，我打算从三个方面来回答：</p> <ul><li>了解二叉树、AVL树、B树的概念</li> <li>B树和B+树的应用场景</li></ul> <ol><li>B树是一种多路平衡查找树，为了更形象的理解。</li></ol> <p>二叉树，每个节点支持两个分支的树结构，相比于单向链表，多了一个分支。</p> <p>二叉查找树，在二叉树的基础上增加了一个规则，左子树的所有节点的值都小于它的根节点，右子树的所有子节点都大于它的根节点。</p> <p><img src="https://pic1.zhimg.com/v2-0b76cdd2e3a55913edffd0d52a9f69a3_720w.jpg?source=d16d100b" alt="img"></p> <p>二叉查找树会出现斜树问题，导致时间复杂度增加，因此又引入了一种平衡二叉树，它具有二叉查找树的所有特点，同时增加了一个规则：”它的左右两个子树的高度差的绝对值不超过1“。平衡二叉树会采用左旋、右旋的方式来实现平衡。</p> <p><img src="https://pica.zhimg.com/v2-cf8995ae489f1db63a59319860cbbff1_720w.jpg?source=d16d100b" alt="img"></p> <p>而B树是一种多路平衡查找树，它满足平衡二叉树的规则，但是它可以有多个子树，子树的数量取决于关键字的数量，比如这个图中根节点有两个关键字3和5，那么它能够拥有的子路数量=关键字数+1。</p> <p>因此从这个特征来看，在存储同样数据量的情况下，平衡二叉树的高度要大于B树。</p> <p><img src="https://pica.zhimg.com/v2-29387c5eef0b26be75babccf9b123d7a_720w.jpg?source=d16d100b" alt="img"></p> <p>B+树，其实是在B树的基础上做的增强，最大的区别有两个：</p> <ol><li><ol><li>B树的数据存储在每个节点上，而B+树中的数据是存储在叶子节点，并且通过链表的方式把叶子节点中的数据进行连接。</li> <li>B+树的子路数量等于关键字数</li></ol></li></ol> <p>这个是B树的存储结构，从B树上可以看到每个节点会存储数据。</p> <p><img src="https://pic1.zhimg.com/v2-5acad4af62691fee7f08146393bf6c4a_720w.jpg?source=d16d100b" alt="img"></p> <p>这个是B+树，B+树的所有数据是存储在叶子节点，并且叶子节点的数据是用双向链表关联的。</p> <p><img src="https://pic1.zhimg.com/v2-dedae76d46926b2f3b1cc67415e3f38b_720w.jpg?source=d16d100b" alt="img"></p> <p>2.B树和B+树，一般都是应用在文件系统和数据库系统中，用来减少磁盘IO带来的性能损耗。</p> <p>以Mysql中的InnoDB为例，当我们通过select语句去查询一条数据时，InnoDB需要从磁盘上去读取数据，这个过程会涉及到磁盘IO以及磁盘的随机IO</p> <p><img src="https://pic2.zhimg.com/v2-c6f2b9962be5824a938083da26c3b461_720w.jpg?source=d16d100b" alt="img"></p> <p>我们知道磁盘IO的性能是特别低的，特别是随机磁盘IO。</p> <p>因为，磁盘IO的工作原理是，首先系统会把数据逻辑地址传给磁盘，磁盘控制电路按照寻址逻辑把逻辑地址翻译成物理地址，也就是确定要读取的数据在哪个磁道，哪个扇区。</p> <p>为了读取这个扇区的数据，需要把磁头放在这个扇区的上面，为了实现这一个点，磁盘会不断旋转，把目标扇区旋转到磁头下面，使得磁头找到对应的磁道，这里涉及到寻道事件以及旋转时间。</p> <p>很明显，磁盘IO这个过程的性能开销是非常大的，特别是查询的数据量比较多的情况下。</p> <p>所以在InnoDB中，干脆对存储在磁盘块上的数据建立一个索引，然后把索引数据以及索引列对应的磁盘地址，以B+树的方式来存储。</p> <p>如图所示，当我们需要查询目标数据的时候，根据索引从B+树中查找目标数据即可，由于B+树分路较多，所以只需要较少次数的磁盘IO就能查找到。</p> <p><img src="https://pica.zhimg.com/v2-acb0c2a8fadfe57a7917e399fa40e1ea_720w.jpg?source=d16d100b" alt="img"></p> <p>3.为什么用B树或者B+树来做索引结构？原因是AVL树的高度要比B树的高度要高，而高度就意味着磁盘IO的数量。所以为了减少磁盘IO的次数，文件系统或者数据库才会采用B树或者B+树。</p> <p>以上就是我对B树和B+树的理解！</p> <p><strong>总结</strong></p> <p>数据结构在实际开发中非常常见，比如数组、链表、双向链表、红黑树、跳跃表、B树、B+树、队列等。</p> <p>在我看来，数据结构是编程中最重要的基本功之一。</p> <p>学了顺序表和链表，我们就能知道查询操作比较多的场景中应该用顺序表，修改操作比较多的场景应该使用链表。</p> <p>学了队列之后，就知道对于FIFO的场景中，应该使用队列。</p> <p>学了树的结构后，会发现原来查找类的场景，还可以更进一步提升查询性能。</p> <p>基本功决定大家在技术这个岗位上能够走到的高度。</p> <p>如果最近大家遇到一些场景类和方案设计类的问题，欢迎私信我，我在后续的内容中给大家做解答！</p> <h2 id="concurrenthashmap-底层具体实现知道吗-实现原理是什么"><a href="#concurrenthashmap-底层具体实现知道吗-实现原理是什么" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/501250784" target="_blank" rel="noopener noreferrer">ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>这个问题我从这三个方面来回答：</p> <ol><li>ConcurrentHashMap的整体架构</li> <li>ConcurrentHashMap的基本功能</li> <li>ConcurrentHashMap在性能方面的优化</li></ol> <ul><li>ConcurrentHashMap的整体架构</li></ul> <p><img src="https://pic1.zhimg.com/v2-d9f22d2eea80cf0f5dd7370a0efed461_720w.jpg?source=d16d100b" alt="img"></p> <p>这个是ConcurrentHashMap在JDK1.8中的存储结构，它是由数组、单向链表、红黑树组成。</p> <p>当我们初始化一个ConcurrentHashMap实例时，默认会初始化一个长度为16的数组。由ConcurrentHashMap它的核心仍然是hash表，所以必然会存在hash冲突问题。</p> <p>ConcurrentHashMap采用链式寻址法来解决hash冲突。</p> <p>当hash冲突比较多的时候，会造成链表长度较长，这种情况会使得ConcurrentHashMap中数据元素的查询复杂度变成O(n)。因此在JDK1.8中，引入了红黑树的机制。</p> <p>当数组长度大于64并且链表长度大于等于8的时候，单项链表就会转换为红黑树。</p> <p>另外，随着ConcurrentHashMap的动态扩容，一旦链表长度小于8，红黑树会退化成单向链表。</p> <ul><li>ConcurrentHashMap的基本功能</li></ul> <p>ConcurrentHashMap本质上是一个HashMap，因此功能和HashMap一样，但是ConcurrentHashMap在HashMap的基础上，提供了并发安全的实现。</p> <p>并发安全的主要实现是通过对指定的Node节点加锁，来保证数据更新的安全性。</p> <p><img src="https://pica.zhimg.com/v2-3ef02747aef441050d996f36ee8b0aee_720w.jpg?source=d16d100b" alt="img"></p> <ul><li>ConcurrentHashMap在性能方面做的优化</li></ul> <p>如果在并发性能和数据安全性之间做好平衡，在很多地方都有类似的设计，比如cpu的三级缓存、mysql的buffer_pool、Synchronized的锁升级等等。</p> <p>ConcurrentHashMap也做了类似的优化，主要体现在以下几个方面：</p> <ul><li><ul><li>在JDK1.8中，ConcurrentHashMap锁的粒度是数组中的某一个节点，而在JDK1.7，锁定的是Segment，锁的范围要更大，因此性能上会更低。</li> <li>引入红黑树，降低了数据查询的时间复杂度，红黑树的时间复杂度是O(logn)。</li> <li>当数组长度不够时，ConcurrentHashMap需要对数组进行扩容，在扩容的实现上，ConcurrentHashMap引入了多线程并发扩容的机制，简单来说就是多个线程对原始数组进行分片后，每个线程负责一个分片的数据迁移，从而提升了扩容过程中数据迁移的效率。</li></ul></li></ul> <p><img src="https://pic1.zhimg.com/v2-4250e6c86714cac8af3bbcbbf972c9c8_720w.jpg?source=d16d100b" alt="img"></p> <ul><li><ul><li>ConcurrentHashMap中有一个size()方法来获取总的元素个数，而在多线程并发场景中，在保证原子性的前提下来实现元素个数的累加，性能是非常低的。ConcurrentHashMap在这个方面的优化主要体现在两个点：</li> <li><ul><li>当线程竞争不激烈时，直接采用CAS来实现元素个数的原子递增。</li> <li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个，再通过CAS实现原子递增。它的核心思想是引入了数组来实现对并发更新的负载。</li></ul></li></ul></li></ul> <p><img src="https://pic2.zhimg.com/v2-5f412045f0a49cf1aacf43483f66ff5e_720w.jpg?source=d16d100b" alt="img"></p> <p>以上就是我对这个问题的理解！</p> <p><strong>总结</strong></p> <p>从高手的回答中可以看到，ConcurrentHashMap里面有很多设计思想值得学习和借鉴。</p> <p>比如锁粒度控制、分段锁的设计等，它们都可以应用在实际业务场景中。</p> <p>很多时候大家会认为这种面试题毫无价值，当你有足够的积累之后，你会发现从这些技术底层的设计思想中能够获得很多设计思路。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。</p> <p>部分高手面试文档已整理，需要的小伙伴可以私信或者评论区留言。</p> <h2 id="dubbo的服务请求失败怎么处理"><a href="#dubbo的服务请求失败怎么处理" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/500662584" target="_blank" rel="noopener noreferrer">Dubbo的服务请求失败怎么处理？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>Dubbo是一个RPC框架，它为我们的应用提供了远程通信能力的封装，同时，Dubbo在RPC通信的基础上，逐步在向一个生态在演进，它涵盖了服务注册、动态路由、容错、服务降级、负载均衡等能力，基本上在微服务架构下面临的问题，Dubbo都可以解决。</p> <p>而对于Dubbo服务请求失败的场景，默认提供了重试的容错机制，也就是说，如果基于Dubbo进行服务间通信出现异常，服务消费者会对服务提供者集群中其他的节点发起重试，确保这次请求成功，默认的额外重试次数是2次。</p> <p>除此之外，Dubbo还提供了更多的容错策略，我们可以根据不同的业务场景来进行选择。</p> <ol><li>快速失败策略，服务消费者只发起一次请求，如果请求失败，就直接把错误抛出去。这种比较适合在非幂等性场景中使用</li> <li>失败安全策略，如果出现服务通信异常，直接把这个异常吞掉不做任何处理</li> <li>失败自动恢复策略，后台记录失败请求，然后通过定时任务来对这个失败的请求进行重发。</li> <li>并行调用多个服务策略，就是把这个消息广播给服务提供者集群，只要有任何一个节点返回，就表示请求执行成功。</li> <li>广播调用策略，逐个调用服务提供者集群，只要集群中任何一个节点出现异常，就表示本次请求失败</li></ol> <p>要注意的是，默认基于重试策略的容错机制中，需要注意幂等性的处理，否则在事务型的操作中，容易出现多次数据变更的问题。</p> <p>以上就是我对这个问题的理解！</p> <p><strong>总结</strong></p> <p>这类的问题，并不需要去花太多时间去背，如果你对于整个技术体系有一定的了解，你就很容易想象到最基本的处理方式。</p> <p>即便是你对Dubbo不熟悉，也能回答一两种！</p> <p>本期的普通人VS高手面试系列就到这里结束了，需要面试资料或者面试问题咨询欢迎私信和评论区留言。</p> <p>另外，我也陆续收到了很多小伙伴的面试题，我会在后续的内容中逐步更新给到大家！</p> <h2 id="什么叫做阻塞队列的有界和无界"><a href="#什么叫做阻塞队列的有界和无界" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/499698719" target="_blank" rel="noopener noreferrer">什么叫做阻塞队列的有界和无界<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>1.阻塞队列，是一种特殊的队列，它在普通队列的基础上提供了两个附加功能</p> <p><img src="https://pica.zhimg.com/v2-0b2cbcdfec6ebbd7a1119aa9eeffb499_720w.jpg?source=d16d100b" alt="img"></p> <p>（1）当队列为空的时候，获取队列中元素的消费者线程会被阻塞，同时唤醒生产者线程。</p> <p>（2）当队列满了的时候，向队列中添加元素的生产者线程被阻塞，同时唤醒消费者线程。</p> <p>2.其中，阻塞队列中能够容纳的元素个数，通常情况下是有界的，比如我们实例化一个 <code>ArrayBlockingList</code>，可以在构造方法中传入一个整形的数字，表示这个基于数组的阻塞队列中能够容纳的元素个数。这种就是有界队列。</p> <p>3.而无界队列，就是没有设置固定大小的队列，不过它并不是像我们理解的那种元素没有任何限制，而是它的元素存储量很大，像LinkedBlockingQueue，它的默认队列长度是Integer.Max_Value，所以我们感知不到它的长度限制。</p> <p>4.无界队列存在比较大的潜在风险，如果在并发量较大的情况下，线程池中可以几乎无限制的添加任务，容易导致内存溢出的问题！</p> <p>以上就是我对这个问题的理解!</p> <p><strong>总结</strong></p> <p>阻塞队列在生产者消费者模型的场景中使用频率比较高，比较典型的就是在线程池中，通过阻塞队列来实现线程任务的生产和消费功能。</p> <p>基于阻塞队列实现的生产者消费者模型比较适合用在异步化性能提升的场景，以及做并发流量缓冲类的场景中！</p> <p>在很多开源中间件中都可以看到这种模型的使用，比如在Zookeeper源码中就大量用到了阻塞队列实现的生产者消费者模型。</p> <h2 id="hashmap是怎么解决哈希冲突的"><a href="#hashmap是怎么解决哈希冲突的" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/499227521" target="_blank" rel="noopener noreferrer">HashMap是怎么解决哈希冲突的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>嗯，这个问题我从四个方面来回答。</p> <p>1.要了解Hash冲突，那首先我们要先了解Hash算法和Hash表。</p> <p><img src="https://pica.zhimg.com/v2-0f574fb1e93bde949d3810d17cca25c5_720w.jpg?source=d16d100b" alt="img"></p> <p>（1）Hash算法，就是把任意长度的输入，通过散列算法，变成固定长度的输出，这个输出结果是散列值。</p> <p>（2）Hash表又叫做“散列表”，它是通过key直接访问在内存存储位置的数据结构，在具体实现上，我们通过hash函数把key映射到表中的某个位置，来获取这个位置的数据，从而加快查找速度。</p> <p>2.所谓hash冲突，是由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，所以总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p> <p>3.通常解决hash冲突的方法有4种。</p> <p>（1）开放定址法，也称为线性探测法，就是从发生冲突的那个位置开始，按照一定的次序从hash表中找到一个空闲的位置，然后把发生冲突的元素存入到这个空闲位置中。ThreadLocal就用到了线性探测法来解决hash冲突的。</p> <p>向这样一种情况</p> <p><img src="https://pic1.zhimg.com/v2-180ace1852ff65e8a84365c2ea66b731_720w.jpg?source=d16d100b" alt="img"></p> <p>在hash表索引1的位置存了一个key=name，当再次添加key=hobby时，hash计算得到的索引也是1，这个就是hash冲突。而开放定址法，就是按顺序向前找到一个空闲的位置来存储冲突的key。</p> <p>（2）链式寻址法，这是一种非常常见的方法，简单理解就是把存在hash冲突的key，以单向链表的方式来存储，比如HashMap就是采用链式寻址法来实现的。</p> <p>向这样一种情况</p> <p><img src="https://pic1.zhimg.com/v2-48d249d72806d0165d9fe0d7962622c5_720w.jpg?source=d16d100b" alt="img"></p> <p>存在冲突的key直接以单向链表的方式进行存储。</p> <p>（3）再hash法，就是当通过某个hash函数计算的key存在冲突时，再用另外一个hash函数对这个key做hash，一直运算直到不再产生冲突。这种方式会增加计算时间，性能影响较大。</p> <p>（4）建立公共溢出区， 就是把hash表分为基本表和溢出表两个部分，凡事存在冲突的元素，一律放入到溢出表中。</p> <p>4.HashMap在JDK1.8版本中，通过链式寻址法+红黑树的方式来解决hash冲突问题，其中红黑树是为了优化Hash表链表过长导致时间复杂度增加的问题。当链表长度大于8并且hash表的容量大于64的时候，再向链表中添加元素就会触发转化。</p> <p>以上就是我对这个问题的理解！</p> <p><strong>总结</strong></p> <p>这道面试题主要考察Java基础，面向的范围是工作1到5年甚至5年以上。</p> <p>因为集合类的对象在项目中使用频率较高，如果对集合理解不够深刻，容易在项目中制造隐藏的BUG。</p> <p>所以，再强调一下，面试的时候，基础是很重要的考核项！！</p> <h2 id="线程池如何知道一个线程的任务已经执行完成"><a href="#线程池如何知道一个线程的任务已经执行完成" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/498468175" target="_blank" rel="noopener noreferrer">线程池如何知道一个线程的任务已经执行完成<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，我会从两个方面来回答。</p> <ol><li>在线程池内部，当我们把一个任务丢给线程池去执行，线程池会调度工作线程来执行这个任务的run方法，run方法正常结束，也就意味着任务完成了。
所以线程池中的工作线程是通过同步调用任务的 <code>run()</code>方法并且等待 <code>run</code>方法返回后，再去统计任务的完成数量。</li> <li>如果想在线程池外部去获得线程池内部任务的执行状态，有几种方法可以实现。</li> <li><ol><li>线程池提供了一个 <code>isTerminated()</code>方法，可以判断线程池的运行状态，我们可以循环判断 <code>isTerminated()</code>方法的返回结果来了解线程池的运行状态，一旦线程池的运行状态是 <code>Terminated</code>，意味着线程池中的所有任务都已经执行完了。想要通过这个方法获取状态的前提是，程序中主动调用了线程池的 <code>shutdown()</code>方法。在实际业务中，一般不会主动去关闭线程池，因此这个方法在实用性和灵活性方面都不是很好。</li> <li>在线程池中，有一个 <code>submit()</code>方法，它提供了一个Future的返回值，我们通过 <code>Future.get()</code>方法来获得任务的执行结果，当线程池中的任务没执行完之前，<code>future.get()</code>方法会一直阻塞，直到任务执行结束。因此，只要 <code>future.get()</code>方法正常返回，也就意味着传入到线程池中的任务已经执行完成了！</li> <li>可以引入一个CountDownLatch计数器，它可以通过初始化指定一个计数器进行倒计时，其中有两个方法分别是 <code>await()</code>阻塞线程，以及 <code>countDown()</code>进行倒计时，一旦倒计时归零，所以被阻塞在 <code>await()</code>方法的线程都会被释放。
基于这样的原理，我们可以定义一个CountDownLatch对象并且计数器为1，接着在线程池代码块后面调用 <code>await()</code>方法阻塞主线程，然后，当传入到线程池中的任务执行完成后，调用 <code>countDown()</code>方法表示任务执行结束。
最后，计数器归零0，唤醒阻塞在 <code>await()</code>方法的线程。</li></ol></li></ol> <p><img src="https://pic3.zhimg.com/v2-dced5ee2eca73986558719c27987c32d_720w.jpg?source=d16d100b" alt="img"></p> <p>基于这个问题，我简单总结一下，不管是线程池内部还是外部，要想知道线程是否执行结束，我们必须要获取线程执行结束后的状态，而线程本身没有返回值，所以只能通过阻塞-唤醒的方式来实现，future.get和CountDownLatch都是这样一个原理。</p> <p>以上就是我对于这个问题的回答！</p> <p><strong>总结</strong></p> <p>大家可以站在面试官的角度来看高手的回答。</p> <p>不难发现，高手对于技术基础的掌握程度，是非常深和全面的。这也是面试官考察这类问题的目的。</p> <p>因此，Mic提醒大家，除了日常的CRUD以外，抽出部分时间去做技术深度和广度的学习是非常有必要的。</p> <h2 id="lock和synchronized区别"><a href="#lock和synchronized区别" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/497903263" target="_blank" rel="noopener noreferrer">lock和synchronized区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>下面我从3个方面来回答</p> <p>1.从功能角度来看，Lock和Synchronized都是Java中用来解决线程安全问题的工具。</p> <p>2.从特性来看</p> <p>（1）Synchronized是Java中的同步关键字，Lock是J.U.C包中提供的接口，这个接口有很多实现类，其中就包括ReentrantLock重入锁</p> <p>（2）Synchronized可以通过两种方式来控制锁的粒度</p> <p><img src="https://pic3.zhimg.com/v2-c02b877bd2fe7dc4525c8e004fc0a56a_720w.jpg?source=d16d100b" alt="img"></p> <p>一种是把synchronized关键字修饰在方法层面</p> <p>另一种是修饰在代码块上，并且我们可以通过Synchronized加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。</p> <p>如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。</p> <p>Lock锁的粒度是通过它里面提供的lock()和unlock()方法决定的</p> <p><img src="https://pic3.zhimg.com/v2-5ec35e8a870b38ce76fe7a3c62cc927a_720w.jpg?source=d16d100b" alt="img"></p> <p>包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于Lock实例的生命周期。</p> <p>（3）Lock比Synchronized的灵活性更高，Lock可以自主决定什么时候加锁，什么时候释放锁，只需要调用lock()和unlock()这两个方法就行，同时Lock还提供了非阻塞的竞争锁方法tryLock()方法，这个方法通过返回true/false来告诉当前线程是否已经有其他线程正在使用锁。</p> <p>Synchronized由于是关键字，所以它无法实现非阻塞竞争锁的方法，另外，Synchronized锁的释放是被动的，就是当Synchronized同步代码块执行完以后或者代码出现异常时才会释放。</p> <p>（4）Lock提供了公平锁和非公平锁的机制，公平锁是指线程竞争锁资源时，如果已经有其他线程正在排队等待锁释放，那么当前竞争锁资源的线程无法插队。而非公平锁，就是不管是否有线程在排队等待锁，它都会尝试去竞争一次锁。 Synchronized只提供了一种非公平锁的实现。</p> <p>3.从性能方面来看，Synchronized和Lock在性能方面相差不大，在实现上会有一些区别，Synchronized引入了偏向锁、轻量级锁、重量级锁以及锁升级的方式来优化加锁的性能，而Lock中则用到了自旋锁的方式来实现性能优化。</p> <p>以上就是我对于这个问题的理解。</p> <p><strong>总结</strong></p> <p>这个问题主要是考察求职责对并发基础能力的掌握。</p> <p>在实际应用中，线程以及线程安全性是非常重要和常见的功能，对于这部分内容如果理解不够深刻，很容易造成生产级别的故障。</p> <h2 id="cpu飙高系统反应慢怎么排查"><a href="#cpu飙高系统反应慢怎么排查" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/497279715" target="_blank" rel="noopener noreferrer">CPU飙高系统反应慢怎么排查？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>好的，关于这个问题，我从四个方面来回答。</p> <ol><li>CPU是整个电脑的核心计算资源，对于一个应用进程来说，CPU的最小执行单元是线程。</li> <li>导致CPU飙高的原因有几个方面
（1）CPU上下文切换过多，对于CPU来说，同一时刻下每个CPU核心只能运行一个线程，如果有多个线程要执行，CPU只能通过上下文切换的方式来执行不同的线程。上下文切换需要做两个事情</li> <li><ol><li><ol><li>保存运行线程的执行状态</li> <li>让处于等待中的线程执行</li></ol></li></ol></li></ol> <p>这两个过程需要CPU执行内核相关指令实现状态保存，如果较多的上下文切换会占据大量CPU资源，从而使得cpu无法去执行用户进程中的指令，导致响应速度下降。
在Java中，文件IO、网络IO、锁等待、线程阻塞等操作都会造成线程阻塞从而触发上下文切换</p> <div class="language- extra-class"><pre><code>（2）CPU资源过度消耗，也就是在程序中创建了大量的线程，或者有线程一直占用CPU资源无法被释放，比如死循环！
</code></pre></div><p>CPU利用率过高之后，导致应用中的线程无法获得CPU的调度，从而影响程序的执行效率！</p> <p>3.既然是这两个问题导致的CPU利用率较高，于是我们可以通过 <code>top</code>命令，找到CPU利用率较高的进程，在通过 <code>Shift+H</code>找到进程中CPU消耗过高的线程，这里有两种情况。</p> <ol><li><ol><li>CPU利用率过高的线程一直是同一个，说明程序中存在线程长期占用CPU没有释放的情况，这种情况直接通过jstack获得线程的Dump日志，定位到线程日志后就可以找到问题的代码。</li> <li>CPU利用率过高的线程id不断变化，说明线程创建过多，需要挑选几个线程id，通过jstack去线程dump日志中排查。</li></ol></li></ol> <p>4.最后有可能定位的结果是程序正常，只是在CPU飙高的那一刻，用户访问量较大，导致系统资源不够。</p> <p>以上就是我对这个问题的理解！</p> <p><strong>总结：</strong></p> <p>从这个问题来看，面试官主要考察实操能力，以及解决问题的思路。</p> <p>如果你没有实操过，但是你知道导致CPU飙高这个现象的原因，并说出你的解决思路，通过面试是没问题的。</p> <p>如果你在面试的时候遇到了一些比较刁钻也奇葩的问题，欢迎私信或在评论区给我留言。</p> <h2 id="innodb如何解决幻读"><a href="#innodb如何解决幻读" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/496666873" target="_blank" rel="noopener noreferrer">innoDB如何解决幻读<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>我会从三个方面来回答：</p> <p>1、 Mysql的事务隔离级别</p> <p>Mysql有四种事务隔离级别，这四种隔离级别代表当存在多个事务并发冲突时，可能出现的脏读、不可重复读、幻读的问题。</p> <p>其中InnoDB在RR的隔离级别下，解决了幻读的问题。</p> <p><img src="https://pic1.zhimg.com/v2-39186c69664df71ad3f2a4fe255f2887_720w.jpg?source=d16d100b" alt="img"></p> <p>2、 什么是幻读？</p> <p>那么， 什么是幻读呢？</p> <p>幻读是指在同一个事务中，前后两次查询相同的范围时，得到的结果不一致</p> <p><img src="https://pic2.zhimg.com/v2-6c1662fd4b9c7ef5b8204b06e2e4c1b7_720w.jpg?source=d16d100b" alt="img"></p> <ul><li>第一个事务里面我们执行了一个范围查询，这个时候满足条件的数据只有一条</li> <li>第二个事务里面，它插入了一行数据，并且提交了</li> <li>接着第一个事务再去查询的时候，得到的结果比第一次查询的结果多出来了一条数据。</li></ul> <p>所以，幻读会带来数据一致性问题。</p> <p>3、 InnoDB如何解决幻读的问题</p> <p>InnoDB引入了间隙锁和next-key Lock机制来解决幻读问题，为了更清晰的说明这两种锁，我举一个例子：</p> <p>假设现在存在这样一个B+ Tree的索引结构，这个结构中有四个索引元素分别是：1、4、7、10。</p> <p><img src="https://pic1.zhimg.com/v2-44bf1e3969e954980e7d179c4210c2ba_720w.jpg?source=d16d100b" alt="img"></p> <p>当我们通过主键索引查询一条记录，并且对这条记录通过for update加锁。</p> <p><img src="https://pic1.zhimg.com/v2-1be0c234f7d9da00569e0a1791932344_720w.jpg?source=d16d100b" alt="img"></p> <p>这个时候，会产生一个记录锁，也就是行锁，锁定id=1这个索引。</p> <p><img src="https://pica.zhimg.com/v2-833248ff7ef5daea33a6e4e44154e6b3_720w.jpg?source=d16d100b" alt="img"></p> <p>被锁定的记录在锁释放之前，其他事务无法对这条记录做任何操作。</p> <p>前面我说过对幻读的定义： 幻读是指在同一个事务中，前后两次查询相同的范围时，得到的结果不一致！</p> <p>注意，这里强调的是范围查询，</p> <p>也就是说，InnoDB引擎要解决幻读问题，必须要保证一个点，就是如果一个事务通过这样一条语句进行锁定时。</p> <p><img src="https://pic2.zhimg.com/v2-cb356958462bb27770ddd755eb50b84a_720w.jpg?source=d16d100b" alt="img"></p> <p>另外一个事务再执行这样一条insert语句，需要被阻塞，直到前面获得锁的事务释放。</p> <p><img src="https://pic3.zhimg.com/v2-b9bfae3a6b3d78699a690e7f17990896_720w.jpg?source=d16d100b" alt="img"></p> <p>所以，在InnoDB中设计了一种间隙锁，它的主要功能是锁定一段范围内的索引记录</p> <p><img src="https://pic1.zhimg.com/v2-545603db4b740ed714d9cea188a8859e_720w.jpg?source=d16d100b" alt="img"></p> <p>当对查询范围id&gt;4 and id &lt;7加锁的时候，会针对B+树中（4，7）这个开区间范围的索引加间隙锁。</p> <p>意味着在这种情况下，其他事务对这个区间的数据进行插入、更新、删除都会被锁住。</p> <p>但是，还有另外一种情况，比如像这样</p> <p><img src="https://pica.zhimg.com/v2-e9b609c1f72a2bc6a7831acb8b45bc10_720w.jpg?source=d16d100b" alt="img"></p> <p>这条查询语句是针对id&gt;4这个条件加锁，那么它需要锁定多个索引区间，所以在这种情况下InnoDB引入了next-key Lock机制。</p> <p>next-key Lock相当于间隙锁和记录锁的合集，记录锁锁定存在的记录行，间隙锁锁住记录行之间的间隙，而next-key Lock锁住的是两者之和。</p> <p><img src="https://pic3.zhimg.com/v2-7fdc5b8576cb9fe7028c8f5b826c07c2_720w.jpg?source=d16d100b" alt="img"></p> <p>每个数据行上的非唯一索引列上都会存在一把next-key lock，当某个事务持有该数据行的next-key lock时，会锁住一段左开右闭区间的数据。</p> <p>因此，当通过id&gt;4这样一种范围查询加锁时，会加next-key Lock，锁定的区间范围是：(4, 7] , (7,10],(10,+∞]</p> <p><img src="https://pic3.zhimg.com/v2-ed16966619c279c94b14c1deb4b8de24_720w.jpg?source=d16d100b" alt="img"></p> <p>间隙锁和next-key Lock的区别在于加锁的范围，间隙锁只锁定两个索引之间的引用间隙，而next-key Lock会锁定多个索引区间，它包含记录锁和间隙锁。</p> <p>当我们使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这种情况下我们使用的就是临键锁，它是MySQL里面默认的行锁算法。</p> <p>4 、总结</p> <p>虽然InnoDB中通过间隙锁的方式解决了幻读问题，但是加锁之后一定会影响到并发性能，因此，如果对性能要求较高的业务场景中，可以把隔离级别设置成RC，这个级别中不存在间隙锁。</p> <p>以上就是我对于innoDB如何解决幻读问题的理解！</p> <p><strong>总结：</strong></p> <p>通过这个面试题可以发现，大厂面试对于基本功的考察还是比较严格的。</p> <p>不过，不管是为了应付面试，还是为以后的职业规划做铺垫， 技术能力的高低都是你在这个行业的核心竞争力。</p> <p>另外，高手面试文档部分已整理，需要的小伙伴可以私信我获取。</p> <h2 id="kafka的零拷贝原理"><a href="#kafka的零拷贝原理" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/495715966" target="_blank" rel="noopener noreferrer">Kafka的零拷贝原理?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>在实际应用中，如果我们需要把磁盘中的某个文件内容发送到远程服务器上，如图</p> <p><img src="https://pic1.zhimg.com/v2-07d3fcae47994561603f5525b67ea770_720w.jpg?source=d16d100b" alt="img"></p> <p>那么它必须要经过几个拷贝的过程：</p> <ol><li>从磁盘中读取目标文件内容拷贝到内核缓冲区</li> <li>CPU控制器再把内核缓冲区的数据赋值到用户空间的缓冲区中</li> <li>接着在应用程序中，调用 <code>write()</code>方法，把用户空间缓冲区中的数据拷贝到内核下的Socket Buffer中。</li> <li>最后，把在内核模式下的SocketBuffer中的数据赋值到网卡缓冲区（NIC Buffer)</li> <li>网卡缓冲区再把数据传输到目标服务器上。</li></ol> <p>在这个过程中我们可以发现，数据从磁盘到最终发送出去，要经历4次拷贝，而在这四次拷贝过程中，有两次拷贝是浪费的，分别是：</p> <ol><li>从内核空间赋值到用户空间</li> <li>从用户空间再次复制到内核空间</li></ol> <p>除此之外，由于用户空间和内核空间的切换会带来CPU的上线文切换，对于CPU性能也会造成性能影响。</p> <p>而零拷贝，就是把这两次多于的拷贝省略掉，应用程序可以直接把磁盘中的数据从内核中直接传输给Socket，而不需要再经过应用程序所在的用户空间，如下图所示。</p> <p><img src="https://pica.zhimg.com/v2-657efb3b07a32792f0476373bb687e94_720w.jpg?source=d16d100b" alt="img"></p> <p>零拷贝通过DMA（Direct Memory Access）技术把文件内容复制到内核空间中的Read Buffer。</p> <p>接着把包含数据位置和长度信息的文件描述符加载到Socket Buffer中，DMA引擎直接可以把数据从内核空间中传递给网卡设备。</p> <p>在这个流程中，数据只经历了两次拷贝就发送到了网卡中，并且减少了2次cpu的上下文切换，对于效率有非常大的提高。</p> <p>所以，所谓零拷贝，并不是完全没有数据赋值，只是相对于用户空间来说，不再需要进行数据拷贝。对于前面说的整个流程来说，零拷贝只是减少了不必要的拷贝次数而已。</p> <p>在程序中如何实现零拷贝呢？</p> <ul><li>在Linux中，零拷贝技术依赖于底层的sendfile()方法实现。</li> <li>在Java中，FileChannal.transferTo() 方法的底层实现就是 sendfile() 方法。</li></ul> <p>除此之外，还有一个 mmap 的文件映射机制</p> <p>它的原理是：将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件。使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。</p> <p>以上就是我对于Kafka中零拷贝原理的理解</p> <p><strong>总结</strong></p> <p>本次的面试题涉及到一些计算机底层的原理，基本上也是业务程序员的知识盲区。</p> <p>但我想提醒大家，做开发其实和建房子一样，要想楼层更高更稳，首先地基要打牢固。</p> <p>另外，如果你有任何面试相关的疑问，欢迎私信或评论区给我留言。</p> <h2 id="spring-boot的约定优于配置-你的理解是什么"><a href="#spring-boot的约定优于配置-你的理解是什么" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/495138047" target="_blank" rel="noopener noreferrer">Spring Boot的约定优于配置，你的理解是什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>从4个方面来回答。</p> <p>1.首先， 约定优于配置是一种软件设计的范式，它的核心思想是减少软件开发人员对于配置项的维护，从而让开发人员更加聚焦在业务逻辑上。</p> <p>2.Spring Boot就是约定优于配置这一理念下的产物，它类似于Spring框架下的一个脚手架，通过Spring Boot，我们可以快速开发基于Spring生态下的应用程序。</p> <p>3.基于传统的Spring框架开发web应用，我们需要做很多和业务开发无关并且只需要做一次的配置，比如</p> <p>（1）管理jar包依赖</p> <p>（2）web.xml维护</p> <p>（3）Dispatch-Servlet.xml配置项维护</p> <p>（4）应用部署到Web容器</p> <p>（5）第三方组件集成到Spring IOC容器中的配置项维护</p> <p>而在Spring Boot中，我们不需要再去做这些繁琐的配置，Spring Boot已经自动帮我们完成了，这就是约定由于配置思想的体现。</p> <p>4.Spring Boot约定由于配置的体现有很多，比如</p> <p>（1）Spring Boot Starter启动依赖，它能帮我们管理所有jar包版本</p> <p>（2）如果当前应用依赖了spring mvc相关的jar，那么Spring Boot会自动内置Tomcat容器来运行web应用，我们不需要再去单独做应用部署。</p> <p>（3）Spring Boot的自动装配机制的实现中，通过扫描约定路径下的spring.factories文件来识别配置类，实现Bean的自动装配。</p> <p>（4）默认加载的配置文件application.properties 等等。</p> <p>总的来说，约定优于配置是一个比较常见的软件设计思想，它的核心本质都是为了更高效以及更便捷的实现软件系统的开发和维护。</p> <p><strong>总结</strong></p> <p>关于本期文章的这个问题，你知道该怎么回答了吗？</p> <p>另外，如果你有任何面试相关的疑问，欢迎私信和在评论区留言。</p> <h2 id="谈谈你对seata的理解"><a href="#谈谈你对seata的理解" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/494461294" target="_blank" rel="noopener noreferrer">谈谈你对Seata的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>1.在微服务架构下，由于数据库和应用服务的拆分，导致原本一个事务单元中的多个DML操作，变成了跨进程或者跨数据库的多个事务单元的多个DML操作，而传统的数据库事务无法解决这类的问题，所以就引出了分布式事务的概念。</p> <p>2.分布式事务本质上要解决的就是跨网络节点的多个事务的数据一致性问题，业内常见的解决方法有两种</p> <p>（1）强一致性，就是所有的事务参与者要么全部成功，要么全部失败，全局事务协调者需要知道每个事务参与者的执行状态，再根据状态来决定数据的提交或者回滚！</p> <p>（2）最终一致性，也叫弱一致性，也就是多个网络节点的数据允许出现不一致的情况，但是在最终的某个时间点会达成数据一致。</p> <div class="language- extra-class"><pre><code>基于CAP定理我们可以知道，强一致性方案对于应用的性能和可用性会有影响，所以对于数据一致性要求不高的场景，就会采用最终一致性算法。
</code></pre></div><p>3.在分布式事务的实现上，对于强一致性，我们可以通过基于XA协议下的二阶段提交来实现，对于弱一致性，可以基于TCC事务模型、可靠性消息模型等方案来实现。</p> <p>4.市面上有很多针对这些理论模型实现的分布式事务框架，我们可以在应用中集成这些框架来实现分布式事务。
而Seata就是其中一种，它是阿里开源的分布式事务解决方案，提供了高性能且简单易用的分布式事务服务。</p> <p>Seata中封装了四种分布式事务模式，分别是：</p> <ul><li>AT模式，是一种基于本地事务+二阶段协议来实现的最终数据一致性方案，也是Seata默认的解决方案</li></ul> <p><img src="https://pic2.zhimg.com/v2-3788afad6def9f0be36e6962cf411641_720w.jpg?source=d16d100b" alt="img"></p> <ul><li>TCC模式，TCC事务是Try、Confirm、Cancel三个词语的缩写，简单理解就是把一个完整的业务逻辑拆分成三个阶段，然后通过事务管理器在业务逻辑层面根据每个分支事务的执行情况分别调用该业务的Confirm或者Cacel方法。</li></ul> <p><img src="https://pica.zhimg.com/v2-3a735181eaafd474f2e498c594967b42_720w.jpg?source=d16d100b" alt="img"></p> <ul><li>Saga模式，Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者。</li></ul> <p><img src="https://pic1.zhimg.com/v2-bf327b3f41fcbf0eb5eea98a211cc979_720w.jpg?source=d16d100b" alt="img"></p> <ul><li>XA模式，XA可以认为是一种强一致性的事务解决方法，它利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。</li></ul> <p><img src="https://pica.zhimg.com/v2-06f0769f1dfcfae8049fa5f15b2d52f5_720w.jpg?source=d16d100b" alt="img"></p> <p>从这四种模型中不难看出，在不同的业务场景中，我们可以使用Seata的不同事务模型来解决不同业务场景中的分布式事务问题，因此我们可以认为Seata是一个一站式的分布式事务解决方案。</p> <p><strong>总结</strong></p> <p>看完的小伙伴们，你是否通过高手的回答找到了这类问题的回答方式呢？</p> <p>面试的时候遇到这种宽泛的问题时，先不用慌， 首先自己要有一个回答的思路。</p> <p>按照技术的话术，就是先给自己大脑中的知识建立一个索引，然后基于索引来定位你的知识。</p> <p>我对于这类问题，建立的索引一般有几个：</p> <ol><li>它是什么？</li> <li>它能解决什么问题？</li> <li>它有哪些特点和优势？</li> <li>它的核心原理，为什么能解决这类问题？</li></ol> <p>大家对照这几个索引去回答今天的这个面试题，是不是就更清晰了？</p> <p>好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得一键三连，加个关注。</p> <h2 id="fail-safe机制与fail-fast机制分别有什么作用"><a href="#fail-safe机制与fail-fast机制分别有什么作用" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/493862561" target="_blank" rel="noopener noreferrer">Fail-safe机制与Fail-fast机制分别有什么作用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>Fail-safe和Fail-fast，是多线程并发操作集合时的一种失败处理机制。</p> <p>Fail-fast ： 表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败，像这种情况</p> <p><img src="https://pic1.zhimg.com/v2-fafc450b9a694bfe2913a7a2bc81918f_720w.jpg?source=d16d100b" alt="img"></p> <p>定义一个Map集合，使用Iterator迭代器进行数据遍历，在遍历过程中，对集合数据做变更时，就会发生Fail-fast。</p> <p>java.util包下的集合类都是快速失败机制的, 常见的的使用Fail-fast方式遍历的容器有HashMap和ArrayList等。</p> <p>Fail-safe：表示失败安全，也就是在这种机制下，出现集合元素的修改，不会抛出ConcurrentModificationException。</p> <p>原因是采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，</p> <p>在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到</p> <p>比如这种情况</p> <p><img src="https://pic3.zhimg.com/v2-a4e737871d48f55e1f9853d39aa8578d_720w.jpg?source=d16d100b" alt="img"></p> <p>定义了一个CopyOnWriteArrayList，在对这个集合遍历过程中，对集合元素做修改后，不会抛出异常，但同时也不会打印出增加的元素。</p> <p>java.util.concurrent包下的容器都是安全失败的,可以在多线程下并发使用,并发修改。</p> <p>常见的的使用Fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等。</p> <p><strong>总结</strong></p> <p>好的， Fail-safe和Fail-fast 的作用，你理解了吗？</p> <p>你们是否有更好的回答方式？ 欢迎在评论区给我留言！</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得一键三连，加个关注。</p> <h2 id="谈谈你对aqs的理解"><a href="#谈谈你对aqs的理解" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/492247399" target="_blank" rel="noopener noreferrer">谈谈你对AQS的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>AQS是多线程同步器，它是J.U.C包中多个组件的底层实现，如Lock、CountDownLatch、Semaphore等都用到了AQS。</p> <p>从本质上来说，AQS提供了两种锁机制，分别是排它锁和共享锁。</p> <p>排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock重入锁实现就是用到了AQS中的排它锁功能。</p> <p>共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都是用到了AQS中的共享锁功能。</p> <p><strong>总结</strong>
关于普通人和高手对于这个问题的回答，哪个更加好呢？ 你们如果有更好的回答，可以在下方评论区留言。</p> <p>另外，我整理了一张比较完整的并发编程知识体系的脑图，大家感兴趣的可以私信我获取。</p> <p>本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得一键三连，加个关注。</p></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/vuepress/tags/?tag=mic%E6%9E%B6%E6%9E%84" title="标签">#mic架构</a></div> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/vuepress/pages/8ca047/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">mic面试题目</div></a> <a href="/vuepress/pages/f56c1b/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">mysql</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/vuepress/pages/8ca047/" class="prev">mic面试题目</a></span> <span class="next"><a href="/vuepress/pages/f56c1b/">mysql</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:mlcai0419@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://www.zhihu.com/" title="知乎" target="_blank" class="iconfont icon-zhihu"></a><a href="https://juejin.cn" title="掘金" target="_blank" class="iconfont icon-juejin"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2024
    <span>进阶指南 | <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备2022001441号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.d9de98a9.js" defer></script><script src="/vuepress/assets/js/3.9604ce54.js" defer></script><script src="/vuepress/assets/js/2.e97bb777.js" defer></script><script src="/vuepress/assets/js/50.4fa99a04.js" defer></script>
  </body>
</html>
